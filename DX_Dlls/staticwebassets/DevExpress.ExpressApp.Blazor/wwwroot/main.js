/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./Scripts/LayoutEditor/common.ts":
/*!****************************************!*\
  !*** ./Scripts/LayoutEditor/common.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LayoutElementType: () => (/* binding */ LayoutElementType)\n/* harmony export */ });\nvar LayoutElementType;\r\n(function (LayoutElementType) {\r\n    LayoutElementType[\"Item\"] = \"LayoutItem\";\r\n    LayoutElementType[\"Group\"] = \"LayoutGroup\";\r\n    LayoutElementType[\"TabGroup\"] = \"LayoutTabbedGroup\";\r\n    LayoutElementType[\"TabContent\"] = \"LayoutTabGroup\";\r\n})(LayoutElementType || (LayoutElementType = {}));\r\n;\r\n\n\n//# sourceURL=webpack:///./Scripts/LayoutEditor/common.ts?");

/***/ }),

/***/ "./Scripts/LayoutEditor/dragging.ts":
/*!******************************************!*\
  !*** ./Scripts/LayoutEditor/dragging.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dragged: () => (/* binding */ Dragged),\n/* harmony export */   DropPosition: () => (/* binding */ DropPosition)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./Scripts/LayoutEditor/common.ts\");\n\r\nvar DropPosition;\r\n(function (DropPosition) {\r\n    DropPosition[\"Top\"] = \"Top\";\r\n    DropPosition[\"Bottom\"] = \"Bottom\";\r\n    DropPosition[\"Left\"] = \"Left\";\r\n    DropPosition[\"Right\"] = \"Right\";\r\n    DropPosition[\"Inside\"] = \"Inside\";\r\n})(DropPosition || (DropPosition = {}));\r\nclass Dragged {\r\n    constructor(node, titlePromise, startX, startY, layoutTree, draggedItem) {\r\n        this.dropItemDeltaX = 0;\r\n        this.dropItemDeltaY = 0;\r\n        this.isHidden = true;\r\n        this.dragInProgress = false;\r\n        this.dropZone = null;\r\n        this.cursorClass = null;\r\n        this.dropzoneSuffix = null;\r\n        this.target = node;\r\n        this.element = node.element;\r\n        this.titlePromise = titlePromise;\r\n        this.startY = startY;\r\n        this.startX = startX;\r\n        this.dropItemDeltaX = 0;\r\n        this.dropItemDeltaY = 0;\r\n        this.layoutTree = layoutTree;\r\n        this.dragElement = draggedItem;\r\n        this.lastCaptureTimestamp = new Date();\r\n    }\r\n    getTarget() {\r\n        return this.target;\r\n    }\r\n    start() {\r\n        this.dragInProgress = true;\r\n        this.highlightDraggedElement();\r\n        this.titlePromise.then(title => this.dragInProgress ? this.dragElement.firstElementChild.innerText = title : null);\r\n    }\r\n    update(x, y) {\r\n        if (!this.dragInProgress) {\r\n            return;\r\n        }\r\n        if (this.isHidden) {\r\n            const rect = this.element.getBoundingClientRect();\r\n            const dx = x - this.startX;\r\n            const dy = y - this.startY;\r\n            if ((dx * dx + dy * dy) > 200\r\n                || x < rect.left || rect.right < x\r\n                || y < rect.top || rect.bottom < y) {\r\n                this.dragElement.classList.remove(\"d-none\");\r\n                this.isHidden = false;\r\n            }\r\n        }\r\n        if (!this.isHidden) {\r\n            const rect = this.dragElement.getBoundingClientRect();\r\n            this.dropItemDeltaX += x - (rect.left + 4);\r\n            this.dropItemDeltaY += y - (rect.top + 4);\r\n            this.dragElement.style.transform =\r\n                `translate(${this.dropItemDeltaX}px,${this.dropItemDeltaY}px)`;\r\n            this.captureDropZone(x, y);\r\n        }\r\n    }\r\n    finish(x, y) {\r\n        this.dragInProgress = false;\r\n        this.releaseDropZone();\r\n        this.restoreElementStyles();\r\n        this.dragElement.style.removeProperty(\"transform\");\r\n        this.dragElement.classList.add(\"d-none\");\r\n        const dropZone = this.getLayoutDropZone(x, y, document.elementsFromPoint(x, y));\r\n        if (dropZone) {\r\n            return {\r\n                draggedNode: this.target,\r\n                dropZoneNode: dropZone.node,\r\n                position: dropZone.position\r\n            };\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    highlightDraggedElement() {\r\n        this.element.classList.add(\"xaf-layouteditor-dragging-element\");\r\n    }\r\n    restoreElementStyles() {\r\n        this.dragElement.style.transform = \"\";\r\n        this.element.classList.remove(\"xaf-layouteditor-dragging-element\");\r\n    }\r\n    releaseDropZone() {\r\n        if (this.dropZone && this.dropzoneSuffix) {\r\n            this.dropZone.element.classList.remove(\"xaf-layouteditor-dropzone\" + this.dropzoneSuffix);\r\n            this.dropZone.element.classList.remove(\"xaf-layouteditor-dropzone\");\r\n            //this.dropZone.treeNode?.classList.remove(\"xaf-layouteditor-dropzone\" + this.dropzoneSuffix);\r\n            //this.dropZone.treeNode?.classList.remove(\"xaf-layouteditor-dropzone\");\r\n            this.dropZone = null;\r\n            this.dropzoneSuffix = null;\r\n        }\r\n        if (this.cursorClass) {\r\n            this.dragElement.classList.remove(this.cursorClass);\r\n            this.cursorClass = null;\r\n        }\r\n    }\r\n    captureDropZone(x, y) {\r\n        const now = new Date();\r\n        if (now.valueOf() - this.lastCaptureTimestamp.valueOf() < Dragged.MIN_MILLISECONDS_BETWEEN_UPDATES) {\r\n            return;\r\n        }\r\n        this.lastCaptureTimestamp = now;\r\n        this.releaseDropZone();\r\n        const result = this.getLayoutDropZone(x, y, document.elementsFromPoint(x, y));\r\n        if (!result) {\r\n            return;\r\n        }\r\n        const position = result.position;\r\n        const dropZone = result.node;\r\n        let newStyleSuffix;\r\n        switch (position) {\r\n            case DropPosition.Top:\r\n                newStyleSuffix = \"-top\";\r\n                break;\r\n            case DropPosition.Bottom:\r\n                newStyleSuffix = \"-bottom\";\r\n                break;\r\n            case DropPosition.Left:\r\n                newStyleSuffix = \"-left\";\r\n                break;\r\n            case DropPosition.Right:\r\n                newStyleSuffix = \"-right\";\r\n                break;\r\n            default:\r\n                newStyleSuffix = \"-whole\";\r\n                break;\r\n        }\r\n        this.cursorClass = \"xaf-layouteditor-dropcursor\" + newStyleSuffix;\r\n        this.dragElement.classList.add(this.cursorClass);\r\n        this.dropzoneSuffix = newStyleSuffix;\r\n        dropZone.element.classList.add(\"xaf-layouteditor-dropzone\" + this.dropzoneSuffix);\r\n        dropZone.element.classList.add(\"xaf-layouteditor-dropzone\");\r\n        //dropZone.treeNode?.classList.add(\"xaf-layouteditor-dropzone\" + this.dropzoneSuffix);\r\n        //dropZone.treeNode?.classList.add(\"xaf-layouteditor-dropzone\");\r\n        this.dropZone = dropZone;\r\n        return;\r\n    }\r\n    getDropZone(x, y) {\r\n        const elementsUnderCursor = document.elementsFromPoint(x, y);\r\n        const main = elementsUnderCursor.findIndex(e => e.classList.contains(\"main\")\r\n            || e.classList.contains(\"dropdown-menu\")\r\n            || e.classList.contains(\"dxbl-window-dialog\"));\r\n        return null;\r\n    }\r\n    getLayoutDropZone(x, y, elementsUnderCursor) {\r\n        var _a;\r\n        if (this.isHidden) {\r\n            return null;\r\n        }\r\n        let node = null;\r\n        let element = null;\r\n        //console.log(elementsUnderCursor);\r\n        for (let e of elementsUnderCursor) {\r\n            if (e === this.dragElement) {\r\n                continue;\r\n            }\r\n            if (e === this.element) {\r\n                return null;\r\n            }\r\n            if (this.layoutTree.isLayoutRoot(e)) {\r\n                return null;\r\n            }\r\n            if (e.classList.contains(\"xaf-layouteditor-menu-hiddenitems\")) {\r\n                return { node: this.layoutTree.getNodeById(\"xaf-layouteditor-menu-hiddenitems\"), position: DropPosition.Inside };\r\n            }\r\n            if (e.classList.contains(\"dxbl-row\")) {\r\n                e = e.parentElement;\r\n            }\r\n            if (e.classList.contains(\"dxbl-fl-tab-content\")) {\r\n                e = e.parentElement;\r\n            }\r\n            node = this.layoutTree.getNodeByElement(e);\r\n            if (node) {\r\n                element = e;\r\n                break;\r\n            }\r\n        }\r\n        for (let n = node; n !== null; n = n.parent) {\r\n            if (n === this.target) {\r\n                return null;\r\n            }\r\n        }\r\n        if (node == null) {\r\n            return null;\r\n        }\r\n        const itemRect = element.getBoundingClientRect();\r\n        let distance;\r\n        let position;\r\n        if (node.type === _common__WEBPACK_IMPORTED_MODULE_0__.LayoutElementType.Item) {\r\n            if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.id) === \"xaf-layouteditor-menu-hiddenitems\") {\r\n                return { node: node.parent, position: DropPosition.Inside };\r\n            }\r\n            [distance, position] = this.calculateDropPosition(x, y, itemRect);\r\n        }\r\n        else {\r\n            if (node.children.length === 0) {\r\n                return { node, position: DropPosition.Inside };\r\n            }\r\n            [distance, position] = this.calculateDropPosition(x, y, itemRect);\r\n            if (element === node.element) {\r\n                // search for in-between group elements positions too\r\n                // only for vertical groups -- in horizontal there's no margins\r\n                let result = node;\r\n                for (let child of node.children) {\r\n                    if (child.element === this.element)\r\n                        continue;\r\n                    const childRect = child.element.getBoundingClientRect();\r\n                    if (childRect.left < x && x < childRect.right) {\r\n                        if (y < childRect.top && childRect.top - y < distance) {\r\n                            distance = childRect.top - y;\r\n                            position = DropPosition.Top;\r\n                            result = child;\r\n                        }\r\n                        if (childRect.bottom < y && y - childRect.bottom < distance) {\r\n                            distance = y - childRect.bottom;\r\n                            position = DropPosition.Bottom;\r\n                            result = child;\r\n                        }\r\n                    }\r\n                }\r\n                return { node: result, position };\r\n            }\r\n        }\r\n        return { node, position };\r\n    }\r\n    calculateDropPosition(x, y, elementRect) {\r\n        const possibleDropPositions = [\r\n            [y - elementRect.top, DropPosition.Top],\r\n            [elementRect.bottom - y, DropPosition.Bottom],\r\n            [x - elementRect.left, DropPosition.Left],\r\n            [elementRect.right - x, DropPosition.Right]\r\n        ];\r\n        let result = possibleDropPositions.reduce((prev, cur) => cur[0] < prev[0] ? cur : prev);\r\n        if (result[0] < 10) {\r\n            return result;\r\n        }\r\n        if (possibleDropPositions[2][0] < elementRect.width / 3) {\r\n            return possibleDropPositions[2];\r\n        }\r\n        if (possibleDropPositions[3][0] < elementRect.width / 3) {\r\n            return possibleDropPositions[3];\r\n        }\r\n        if (possibleDropPositions[0][0] < elementRect.height / 2) {\r\n            return possibleDropPositions[0];\r\n        }\r\n        else {\r\n            return possibleDropPositions[1];\r\n        }\r\n    }\r\n}\r\nDragged.MIN_MILLISECONDS_BETWEEN_UPDATES = 66;\r\n\r\n\n\n//# sourceURL=webpack:///./Scripts/LayoutEditor/dragging.ts?");

/***/ }),

/***/ "./Scripts/LayoutEditor/layout-editor.ts":
/*!***********************************************!*\
  !*** ./Scripts/LayoutEditor/layout-editor.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeLayoutEditor: () => (/* binding */ initializeLayoutEditor)\n/* harmony export */ });\n/* harmony import */ var _dragging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dragging */ \"./Scripts/LayoutEditor/dragging.ts\");\n/* harmony import */ var _resizing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resizing */ \"./Scripts/LayoutEditor/resizing.ts\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common */ \"./Scripts/LayoutEditor/common.ts\");\nvar _a;\r\n\r\n\r\n\r\nclass LayoutEditorReference {\r\n    constructor(dotnetHelper) {\r\n        this.dotnetHelper = dotnetHelper;\r\n    }\r\n    onElementResizedAsync(args) {\r\n        return this.dotnetHelper.invokeMethodAsync(\"OnElementResized\", args);\r\n    }\r\n    onElementDroppedAsync(args) {\r\n        return this.dotnetHelper.invokeMethodAsync(\"OnElementDropped\", args);\r\n    }\r\n    onElementContextMenuAsync(id, x, y) {\r\n        return this.dotnetHelper.invokeMethodAsync(\"OnElementContextMenuAsync\", id, x, y);\r\n    }\r\n    onElementSelectedAsync(id) {\r\n        return this.dotnetHelper.invokeMethodAsync(\"OnElementSelected\", id);\r\n    }\r\n    getElementTitleAsync(id) {\r\n        return this.dotnetHelper.invokeMethodAsync(\"GetElementTitle\", id);\r\n    }\r\n}\r\nclass LayoutTreeImpl {\r\n    constructor(options, children, ref, rootElement, formElement) {\r\n        this.options = options;\r\n        this.children = children;\r\n        this.ref = ref;\r\n        this.rootElement = rootElement;\r\n        this.formElement = formElement;\r\n    }\r\n    getElementId(e) {\r\n        var _b;\r\n        if (e.matches(this.options.tabSelector)) {\r\n            return e.getAttribute(this.options.tabIdAttributeName);\r\n        }\r\n        if ((_b = e.children.item(0)) === null || _b === void 0 ? void 0 : _b.matches(this.options.formItemIdSelector)) {\r\n            return e.children.item(0).getAttribute(this.options.formItemIdAttributeName);\r\n        }\r\n        return e.getAttribute(this.options.idAttributeName);\r\n    }\r\n    findFormItem(id) {\r\n        var _b, _c;\r\n        return (_c = (_b = this.formElement) === null || _b === void 0 ? void 0 : _b.querySelector(`${this.options.formItemIdSelector}[${this.options.formItemIdAttributeName}=\"${id}\"]`)) !== null && _c !== void 0 ? _c : null;\r\n    }\r\n    isLayoutNode(e) {\r\n        let id = this.getElementId(e);\r\n        return id !== null && id in this.ref;\r\n    }\r\n    isLayoutItem(e) {\r\n        var _b, _c;\r\n        return (_c = ((_b = this.getNodeByElement(e)) === null || _b === void 0 ? void 0 : _b.type) === _common__WEBPACK_IMPORTED_MODULE_2__.LayoutElementType.Item) !== null && _c !== void 0 ? _c : false;\r\n    }\r\n    isLayoutGroup(e) {\r\n        var _b, _c;\r\n        return (_c = ((_b = this.getNodeByElement(e)) === null || _b === void 0 ? void 0 : _b.type) !== _common__WEBPACK_IMPORTED_MODULE_2__.LayoutElementType.Item) !== null && _c !== void 0 ? _c : false;\r\n    }\r\n    getNodeById(id) {\r\n        return id !== null ? this.ref[id] : null;\r\n    }\r\n    getNodeByElement(e) {\r\n        let id = this.getElementId(e);\r\n        return id !== null ? this.ref[id] : null;\r\n    }\r\n    getClosestNodeId(e) {\r\n        let result = null;\r\n        while (e !== null) {\r\n            let id = this.getElementId(e);\r\n            if (id !== null) {\r\n                if (id in this.ref) {\r\n                    return id;\r\n                }\r\n                if (result === null) {\r\n                    result = id;\r\n                }\r\n            }\r\n            e = e.parentElement;\r\n        }\r\n        return result;\r\n    }\r\n    dfs(node, func) {\r\n        func(node);\r\n        for (let child of node.children) {\r\n            this.dfs(child, func);\r\n        }\r\n    }\r\n    forEach(func) {\r\n        for (let node of this.children) {\r\n            this.dfs(node, func);\r\n        }\r\n    }\r\n    isLayoutRoot(e) {\r\n        return LayoutTreeImpl.isLayoutRoot(e);\r\n    }\r\n    static isLayoutRoot(e) {\r\n        return e.matches && e.matches(LayoutTreeImpl.mainClassSelector);\r\n    }\r\n    static isLayoutRootFilter(e) {\r\n        return LayoutTreeImpl.mainClassFilter[LayoutTreeImpl.mainClassList.find(c => e.classList.contains(c))];\r\n    }\r\n}\r\n_a = LayoutTreeImpl;\r\nLayoutTreeImpl.mainClassFilter = {\r\n    \"xaf-layouteditor-menu\": true,\r\n    \"main-content\": true,\r\n    \"nested-content\": false,\r\n    \"xaf-layouteditor-menu-hiddenitems\": false,\r\n    \"xaf-masterdetail-detailview\": true,\r\n    \"xaf-masterdetail-detailview-placeholder\": false,\r\n    \"xaf-masterdetail-container\": false,\r\n    \"dxbl-grid\": false,\r\n    \"xaf-richedit\": false,\r\n    \"dx-designer\": false,\r\n    \"dxbl-modal-root\": false,\r\n    \"dropdown-menu\": false,\r\n    \"xaf-prevent-contextmenu\": false,\r\n};\r\nLayoutTreeImpl.mainClassList = Object.keys(_a.mainClassFilter);\r\nLayoutTreeImpl.mainClassSelector = \".\" + _a.mainClassList.join(\", .\");\r\nclass LayoutEditor extends HTMLElement {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.control = null;\r\n    }\r\n    setControl(control) {\r\n        this.control = control;\r\n    }\r\n    disconnectedCallback() {\r\n        var _b;\r\n        (_b = this.control) === null || _b === void 0 ? void 0 : _b.dispose();\r\n    }\r\n}\r\nclass Control {\r\n    constructor(elementReference, componentReference, options) {\r\n        this.disposed = false;\r\n        this.designMode = false;\r\n        this.customizationFormContent = null;\r\n        this.draggingItem = null;\r\n        this.currentDragTarget = null;\r\n        this.currentResizeTarget = null;\r\n        this.onSplitterPointerDownBound = this.onSplitterPointerDown.bind(this);\r\n        this.onElementPointerDownBound = this.onElementPointerDown.bind(this);\r\n        this.onFormPointerDownBound = this.onPointerDownForm.bind(this);\r\n        this.onPointerMoveBound = this.onPointerMove.bind(this);\r\n        this.onPointerUpBound = this.onPointerUp.bind(this);\r\n        this.onLayoutContextMenuBound = this.onLayoutContextMenu.bind(this);\r\n        this.onFormContextMenuBound = this.onFormContextMenu.bind(this);\r\n        this.onElementContextMenuBound = this.onElementContextMenu.bind(this);\r\n        this.elementReference = elementReference;\r\n        this.componentReference = componentReference;\r\n        this.containerElement = elementReference.parentElement;\r\n        let mainElement = elementReference.parentElement;\r\n        while (mainElement != null && !mainElement.classList.contains(\"main\")) {\r\n            mainElement = mainElement.parentElement;\r\n        }\r\n        this.mainElement = mainElement;\r\n        this.options = options;\r\n        this.layoutTree = new LayoutTreeImpl(options, [], {}, elementReference, null);\r\n        this.resizeSplitters = [];\r\n        elementReference.setControl(this);\r\n        this.containerElement.addEventListener(\"contextmenu\", this.onLayoutContextMenuBound);\r\n    }\r\n    scrollToTreeViewNode(id) {\r\n        var _b, _c;\r\n        const node = this.layoutTree.getNodeById(id);\r\n        const scrollX = window.scrollX;\r\n        const scrollY = window.scrollY;\r\n        (_c = (_b = this.layoutTree.findFormItem(id)) === null || _b === void 0 ? void 0 : _b.parentElement) === null || _c === void 0 ? void 0 : _c.scrollIntoView({ block: \"center\", inline: \"nearest\", behavior: \"instant\" });\r\n        // In case DxWindow was moved outside the body, we want to preserve main window's scroll.\r\n        // Note: \"instant\" behavior is not supported by Chrome. It will default to \"smooth\" and\r\n        // overwrite the previous scrollIntoView call if it would have changed the window's scroll.\r\n        window.scrollTo({ left: scrollX, top: scrollY, behavior: \"instant\" });\r\n        node === null || node === void 0 ? void 0 : node.element.scrollIntoView({ block: \"nearest\", inline: \"nearest\" });\r\n    }\r\n    updateState(designMode, customizationFormContent, draggingItem) {\r\n        this.customizationFormContent = customizationFormContent;\r\n        this.draggingItem = draggingItem;\r\n        this.setDesignMode(designMode);\r\n    }\r\n    setDesignMode(designMode) {\r\n        var _b, _c;\r\n        this.designMode = designMode;\r\n        if (designMode) {\r\n            (_b = this.mainElement) === null || _b === void 0 ? void 0 : _b.classList.add(\"design-mode\");\r\n            this.rebuildLayoutTree();\r\n        }\r\n        else {\r\n            (_c = this.mainElement) === null || _c === void 0 ? void 0 : _c.classList.remove(\"design-mode\");\r\n            this.clearLayoutTree();\r\n        }\r\n    }\r\n    stopDragActions(x, y) {\r\n        document.removeEventListener(\"pointerup\", this.onPointerUpBound);\r\n        if (this.currentDragTarget != null) {\r\n            this.currentDragTarget.finish(x, y);\r\n        }\r\n        if (this.currentResizeTarget != null) {\r\n            this.currentResizeTarget.finish();\r\n        }\r\n    }\r\n    // --- Event handling\r\n    onSplitterPointerDown(args) {\r\n        let element = args.target.parentElement;\r\n        let node = this.layoutTree.getNodeByElement(element);\r\n        if (!node) {\r\n            element = element.parentElement;\r\n            node = this.layoutTree.getNodeByElement(element);\r\n        }\r\n        if (!node) {\r\n            throw new Error(\"Couln't find node for the splitter\");\r\n        }\r\n        args.preventDefault();\r\n        args.stopImmediatePropagation();\r\n        this.stopDragActions(args.clientX, args.clientY);\r\n        this.currentResizeTarget = new _resizing__WEBPACK_IMPORTED_MODULE_1__.Resized(node.prev, node);\r\n        this.currentResizeTarget.start();\r\n        this.elementReference.classList.add(\"xaf-layouteditor-mode-resizing\");\r\n        document.addEventListener(\"pointermove\", this.onPointerMoveBound);\r\n        document.addEventListener(\"pointerup\", this.onPointerUpBound);\r\n        return true;\r\n    }\r\n    onElementPointerDown(args) {\r\n        var _b;\r\n        if (this.disposed || !this.designMode || this.currentDragTarget || args.button !== 0 || document.body.clientWidth < 768) {\r\n            return false;\r\n        }\r\n        const target = args.currentTarget;\r\n        // start dragging\r\n        const elementsUnderCursor = document.elementsFromPoint(args.clientX, args.clientY);\r\n        let clickedHeader = null;\r\n        let node = this.layoutTree.getNodeByElement(target);\r\n        for (let e of elementsUnderCursor) {\r\n            if (e === ((_b = node.parent) === null || _b === void 0 ? void 0 : _b.element)) {\r\n                break;\r\n            }\r\n            if (e.classList.contains(\"resize-splitter-zone\") || e.classList.contains(\"resize-splitter\")\r\n                || e.classList.contains(\"dxbl-group-expand-btn\")) {\r\n                return false;\r\n            }\r\n            if (e.classList.contains(\"dxbl-group-header\") || e.classList.contains(\"dxbl-tabs\")) {\r\n                clickedHeader = e;\r\n                break;\r\n            }\r\n        }\r\n        if (node.type !== _common__WEBPACK_IMPORTED_MODULE_2__.LayoutElementType.Item && clickedHeader == null) {\r\n            return false;\r\n        }\r\n        args.preventDefault();\r\n        args.stopImmediatePropagation();\r\n        this.startDraggingAsync(args.clientX, args.clientY, node);\r\n        return true;\r\n    }\r\n    onPointerDownForm(args) {\r\n        if (this.disposed || !this.designMode || this.currentDragTarget || args.button !== 0 || document.body.clientWidth < 768) {\r\n            return false;\r\n        }\r\n        let target = args.target;\r\n        if (target.children.length === 0) {\r\n            if (target.tagName.toLowerCase() === \"input\") {\r\n                return false;\r\n            }\r\n            target = target.parentElement;\r\n        }\r\n        const idElems = target.querySelectorAll(`${this.options.formItemIdSelector}[${this.options.formItemIdAttributeName}]`);\r\n        if (idElems.length !== 1) {\r\n            return false;\r\n        }\r\n        const id = idElems.item(0).getAttribute(this.options.formItemIdAttributeName);\r\n        if (id == null) {\r\n            return false;\r\n        }\r\n        let node = this.layoutTree.getNodeById(id);\r\n        if (node == null) {\r\n            this.rebuildLayoutTree();\r\n            node = this.layoutTree.getNodeById(id);\r\n            if (node == null) {\r\n                return false;\r\n            }\r\n        }\r\n        args.preventDefault();\r\n        args.stopImmediatePropagation();\r\n        this.startDraggingAsync(args.clientX, args.clientY, node);\r\n        return true;\r\n    }\r\n    startDraggingAsync(x, y, node) {\r\n        this.stopDragActions(x, y);\r\n        const nodeTitlePromise = this.componentReference.getElementTitleAsync(node.id);\r\n        this.currentDragTarget = new _dragging__WEBPACK_IMPORTED_MODULE_0__.Dragged(node, nodeTitlePromise, x, y, this.layoutTree, this.draggingItem);\r\n        this.currentDragTarget.start();\r\n        this.elementReference.classList.add(\"xaf-layouteditor-mode-dragging\");\r\n        document.addEventListener(\"pointermove\", this.onPointerMoveBound);\r\n        document.addEventListener(\"pointerup\", this.onPointerUpBound);\r\n    }\r\n    onPointerMove(args) {\r\n        if (this.disposed || !this.designMode) {\r\n            return;\r\n        }\r\n        if (!this.currentDragTarget && !this.currentResizeTarget) {\r\n            return;\r\n        }\r\n        args.preventDefault();\r\n        if (this.currentDragTarget) {\r\n            this.currentDragTarget.update(args.clientX, args.clientY);\r\n        }\r\n        else if (this.currentResizeTarget) {\r\n            this.currentResizeTarget.update(args.clientX);\r\n        }\r\n    }\r\n    async onPointerUp(args) {\r\n        document.removeEventListener(\"pointermove\", this.onPointerMoveBound);\r\n        document.removeEventListener(\"pointerup\", this.onPointerUpBound);\r\n        if (this.currentDragTarget) {\r\n            const dragResult = this.currentDragTarget.finish(args.clientX, args.clientY);\r\n            this.elementReference.classList.remove(\"xaf-layouteditor-mode-dragging\");\r\n            const target = this.currentDragTarget.getTarget();\r\n            this.currentDragTarget = null;\r\n            if (dragResult) {\r\n                await this.OnElementDroppedAsync(dragResult);\r\n            }\r\n            else {\r\n                await this.OnElementSelectedAsync(target);\r\n            }\r\n        }\r\n        else if (this.currentResizeTarget) {\r\n            const resizeResult = this.currentResizeTarget.finish();\r\n            this.elementReference.classList.remove(\"xaf-layouteditor-mode-resizing\");\r\n            this.currentResizeTarget = null;\r\n            if (resizeResult) {\r\n                await this.OnElementResizedAsync(resizeResult);\r\n            }\r\n        }\r\n    }\r\n    async onLayoutContextMenu(args) {\r\n        this.stopDragActions(args.clientX, args.clientY);\r\n        if (document.body.clientWidth < 768) {\r\n            return;\r\n        }\r\n        let target = args.target;\r\n        let tag = target.tagName.toLowerCase();\r\n        if (!this.designMode &&\r\n            (tag === \"input\"\r\n                || tag === \"textarea\"\r\n                || tag === \"a\"\r\n                || tag === \"xaf-navigation-click-helper\")) {\r\n            return;\r\n        }\r\n        let path = args.composedPath();\r\n        let pathLength = path.findIndex(x => x === this.containerElement);\r\n        if (pathLength < 0)\r\n            return;\r\n        pathLength -= 2;\r\n        if (pathLength > 0) {\r\n            path.length = pathLength;\r\n            let root = path.reverse().find(x => LayoutTreeImpl.isLayoutRoot(x));\r\n            if (root && !LayoutTreeImpl.isLayoutRootFilter(root)) {\r\n                return;\r\n            }\r\n        }\r\n        args.preventDefault();\r\n        args.stopImmediatePropagation();\r\n        await this.OnElementContextMenuAsync(\"\", args.clientX, args.clientY);\r\n    }\r\n    async onFormContextMenu(args) {\r\n        var _b, _c;\r\n        this.stopDragActions(args.clientX, args.clientY);\r\n        let target = args.target;\r\n        let resultId = null;\r\n        if ((_b = this.layoutTree.getNodeById(\"xaf-layouteditor-menu-hiddenitems\")) === null || _b === void 0 ? void 0 : _b.element.contains(target)) {\r\n            return;\r\n        }\r\n        if (target.children.length === 0) {\r\n            if (target.tagName.toLowerCase() === \"input\") {\r\n                return;\r\n            }\r\n            target = target.parentElement;\r\n        }\r\n        const idElems = target.querySelectorAll(`${this.options.formItemIdSelector}[${this.options.formItemIdAttributeName}]`);\r\n        if (idElems.length === 1 || ((_c = target.parentElement) === null || _c === void 0 ? void 0 : _c.classList.contains(\"\"))) {\r\n            resultId = idElems.item(0).getAttribute(this.options.formItemIdAttributeName);\r\n        }\r\n        args.preventDefault();\r\n        args.stopImmediatePropagation();\r\n        await this.OnElementContextMenuAsync(resultId !== null && resultId !== void 0 ? resultId : \"\", args.clientX, args.clientY);\r\n    }\r\n    async onElementContextMenu(args) {\r\n        this.stopDragActions(args.clientX, args.clientY);\r\n        if (document.body.clientWidth < 768) {\r\n            return;\r\n        }\r\n        let target = args.target;\r\n        let resultId = null;\r\n        if (!this.designMode\r\n            && target.tagName.toLowerCase() === \"input\"\r\n            && target.tagName.toLowerCase() === \"textarea\") {\r\n            return;\r\n        }\r\n        if (this.designMode) {\r\n            resultId = this.layoutTree.getClosestNodeId(target);\r\n        }\r\n        args.preventDefault();\r\n        args.stopImmediatePropagation();\r\n        await this.OnElementContextMenuAsync(resultId !== null && resultId !== void 0 ? resultId : \"\", args.clientX, args.clientY);\r\n    }\r\n    // --- component reference API\r\n    async OnElementDroppedAsync(result) {\r\n        await this.componentReference.onElementDroppedAsync({\r\n            elementId: result.draggedNode.id,\r\n            dropZoneId: result.dropZoneNode.id,\r\n            position: result.position\r\n        });\r\n        this.rebuildLayoutTree();\r\n    }\r\n    async OnElementSelectedAsync(result) {\r\n        await this.componentReference.onElementSelectedAsync(result.id);\r\n        this.rebuildLayoutTree();\r\n    }\r\n    async OnElementResizedAsync(result) {\r\n        await this.componentReference.onElementResizedAsync({\r\n            leftElementId: result.leftNode.id,\r\n            rightElementId: result.rightNode.id,\r\n            shiftRatio: result.shiftRatio\r\n        });\r\n        this.rebuildLayoutTree();\r\n    }\r\n    async OnElementContextMenuAsync(layoutNodeId, x, y) {\r\n        await this.componentReference.onElementContextMenuAsync(layoutNodeId, x, y);\r\n    }\r\n    // --- inner logic API\r\n    rebuildLayoutTree() {\r\n        var _b, _c;\r\n        this.clearLayoutTree();\r\n        [this.layoutTree, this.resizeSplitters] = this.buildLayoutTree(this.elementReference);\r\n        // subscribe to events of the new nodes\r\n        (_b = this.layoutTree.formElement) === null || _b === void 0 ? void 0 : _b.addEventListener(\"pointerdown\", this.onFormPointerDownBound);\r\n        (_c = this.layoutTree.formElement) === null || _c === void 0 ? void 0 : _c.addEventListener(\"contextmenu\", this.onFormContextMenuBound);\r\n        this.layoutTree.forEach(node => {\r\n            node.element.addEventListener(\"pointerdown\", this.onElementPointerDownBound);\r\n            node.element.addEventListener(\"contextmenu\", this.onElementContextMenuBound);\r\n        });\r\n        this.resizeSplitters.forEach(([splitter, zone]) => {\r\n            zone.addEventListener(\"pointerdown\", this.onSplitterPointerDownBound);\r\n        });\r\n    }\r\n    clearLayoutTree() {\r\n        var _b, _c;\r\n        // unsubscribe from events of the previous nodes\r\n        (_b = this.layoutTree.formElement) === null || _b === void 0 ? void 0 : _b.removeEventListener(\"pointerdown\", this.onFormPointerDownBound);\r\n        (_c = this.layoutTree.formElement) === null || _c === void 0 ? void 0 : _c.removeEventListener(\"contextmenu\", this.onFormContextMenuBound);\r\n        this.layoutTree.forEach(node => {\r\n            node.element.removeEventListener(\"pointerdown\", this.onElementPointerDownBound);\r\n            node.element.removeEventListener(\"contextmenu\", this.onElementContextMenuBound);\r\n        });\r\n        this.resizeSplitters.forEach(([splitter, zone]) => {\r\n            zone.removeEventListener(\"pointerdown\", this.onSplitterPointerDownBound);\r\n            zone.remove();\r\n            splitter.remove();\r\n        });\r\n        this.resizeSplitters = [];\r\n    }\r\n    buildLayoutTree(rootElement) {\r\n        const layoutItemElements = rootElement.querySelectorAll(`${this.options.itemSelector}, ${this.options.groupSelector}, ${this.options.tabGroupSelector}, ${this.options.tabSelector}`);\r\n        const nodes = [];\r\n        const nodeRef = {};\r\n        const splitters = [];\r\n        let lastProcessedNode = null;\r\n        layoutItemElements.forEach(element => {\r\n            var _b, _c;\r\n            if (!(element instanceof HTMLElement)) {\r\n                throw new Error(\"!(element instanceof HTMLElement)\");\r\n            }\r\n            const currentLayoutNode = {\r\n                element: element,\r\n                id: element.getAttribute(element.matches(this.options.tabSelector)\r\n                    ? this.options.tabIdAttributeName\r\n                    : this.options.idAttributeName),\r\n                type: element.matches(this.options.itemSelector)\r\n                    ? _common__WEBPACK_IMPORTED_MODULE_2__.LayoutElementType.Item\r\n                    : element.matches(this.options.groupSelector)\r\n                        ? _common__WEBPACK_IMPORTED_MODULE_2__.LayoutElementType.Group\r\n                        : element.matches(this.options.tabGroupSelector)\r\n                            ? _common__WEBPACK_IMPORTED_MODULE_2__.LayoutElementType.TabGroup\r\n                            : _common__WEBPACK_IMPORTED_MODULE_2__.LayoutElementType.TabContent,\r\n                children: [],\r\n                parent: null,\r\n                next: null,\r\n                prev: null,\r\n            };\r\n            nodeRef[currentLayoutNode.id] = currentLayoutNode;\r\n            let candidateParentNode = lastProcessedNode;\r\n            while (candidateParentNode !== null) {\r\n                if (candidateParentNode.element.contains(element)) {\r\n                    currentLayoutNode.parent = candidateParentNode;\r\n                    break;\r\n                }\r\n                else {\r\n                    candidateParentNode = candidateParentNode.parent;\r\n                }\r\n            }\r\n            let container = (_c = (_b = currentLayoutNode.parent) === null || _b === void 0 ? void 0 : _b.children) !== null && _c !== void 0 ? _c : nodes;\r\n            if (container.length > 0) {\r\n                let prevNode = container[container.length - 1];\r\n                prevNode.next = currentLayoutNode;\r\n                currentLayoutNode.prev = prevNode;\r\n                if (!element.classList.contains(\"dxbl-col-md-12\") && !prevNode.element.classList.contains(\"dxbl-col-md-12\")\r\n                    && currentLayoutNode.type !== _common__WEBPACK_IMPORTED_MODULE_2__.LayoutElementType.TabContent) {\r\n                    let splitter = document.createElement(\"div\");\r\n                    splitter.classList.add(\"resize-splitter\");\r\n                    element.appendChild(splitter);\r\n                    let splitterZone = document.createElement(\"div\");\r\n                    splitterZone.classList.add(\"resize-splitter-zone\");\r\n                    splitter.appendChild(splitterZone);\r\n                    splitters.push([splitter, splitterZone]);\r\n                }\r\n            }\r\n            container.push(currentLayoutNode);\r\n            lastProcessedNode = currentLayoutNode;\r\n        });\r\n        const customizationForm = this.customizationFormContent;\r\n        const hiddenItemsGroup = {\r\n            element: customizationForm.querySelector(\".xaf-layouteditor-menu-hiddenitems\"),\r\n            id: \"xaf-layouteditor-menu-hiddenitems\",\r\n            type: _common__WEBPACK_IMPORTED_MODULE_2__.LayoutElementType.Group,\r\n            children: [],\r\n            parent: null,\r\n            next: null,\r\n            prev: null,\r\n        };\r\n        nodeRef[hiddenItemsGroup.id] = hiddenItemsGroup;\r\n        const hiddenItemsNodes = hiddenItemsGroup.element.querySelectorAll(this.options.formItemIdSelector);\r\n        hiddenItemsNodes.forEach(item => {\r\n            const node = {\r\n                element: item,\r\n                id: item.getAttribute(this.options.formItemIdAttributeName),\r\n                type: _common__WEBPACK_IMPORTED_MODULE_2__.LayoutElementType.Item,\r\n                children: [],\r\n                parent: hiddenItemsGroup,\r\n                next: null,\r\n                prev: null,\r\n            };\r\n            nodeRef[node.id] = node;\r\n        });\r\n        const layoutTree = new LayoutTreeImpl(this.options, nodes, nodeRef, rootElement, customizationForm);\r\n        return [layoutTree, splitters];\r\n    }\r\n    dispose() {\r\n        var _b;\r\n        if (this.disposed) {\r\n            return;\r\n        }\r\n        (_b = this.containerElement) === null || _b === void 0 ? void 0 : _b.removeEventListener(\"contextmenu\", this.onLayoutContextMenuBound);\r\n        this.setDesignMode(false);\r\n        this.disposed = true;\r\n    }\r\n}\r\nlet initialized = false;\r\nfunction ensureModuleInitialized() {\r\n    if (initialized) {\r\n        return;\r\n    }\r\n    initialized = true;\r\n    window.customElements.define(\"layout-editor\", LayoutEditor);\r\n}\r\nfunction initializeLayoutEditor(elementReference, componentReference, options) {\r\n    ensureModuleInitialized();\r\n    const control = new Control(elementReference, new LayoutEditorReference(componentReference), options);\r\n    return control;\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/LayoutEditor/layout-editor.ts?");

/***/ }),

/***/ "./Scripts/LayoutEditor/resizing.ts":
/*!******************************************!*\
  !*** ./Scripts/LayoutEditor/resizing.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeDirection: () => (/* binding */ ResizeDirection),\n/* harmony export */   Resized: () => (/* binding */ Resized)\n/* harmony export */ });\nconst ResizeDirection = {\r\n    Left: \"Left\", Right: \"Right\"\r\n};\r\nclass Resized {\r\n    constructor(left, right) {\r\n        this.deltaX = 0;\r\n        this.resizeInProgress = false;\r\n        const parent = right.parent;\r\n        if (parent === null) {\r\n            throw new Error(\"Orphan element\");\r\n        }\r\n        this.leftNode = left;\r\n        const leftRect = left.element.getBoundingClientRect();\r\n        this.leftWidth = leftRect.width;\r\n        const leftStyle = window.getComputedStyle(left.element);\r\n        this.leftInitWidth = leftStyle.width;\r\n        this.leftInitMaxWidth = leftStyle.maxWidth;\r\n        this.rightNode = right;\r\n        const rightRect = right.element.getBoundingClientRect();\r\n        this.rightWidth = rightRect.width;\r\n        const elementStyle = window.getComputedStyle(right.element);\r\n        this.rightInitWidth = elementStyle.width;\r\n        this.rightInitMaxWidth = elementStyle.maxWidth;\r\n        this.startingX = rightRect.x;\r\n    }\r\n    start() {\r\n        this.resizeInProgress = true;\r\n        this.highlightResizedNode();\r\n    }\r\n    update(x) {\r\n        if (!this.resizeInProgress) {\r\n            return;\r\n        }\r\n        if (this.rightInitWidth === \"100%\") { // TODO: this is a hack, needs a proper fix for vertical column resizing\r\n            return;\r\n        }\r\n        const delta = x - this.startingX;\r\n        const lNewWidth = this.leftWidth + delta;\r\n        const rNewWidth = this.rightWidth - delta;\r\n        if (rNewWidth < 150 || lNewWidth < 150) {\r\n            return;\r\n        }\r\n        this.deltaX = delta;\r\n        const lRatio = lNewWidth / this.leftWidth;\r\n        const rRatio = rNewWidth / this.rightWidth;\r\n        this.leftNode.element.style.width = `calc(${this.leftInitWidth} * ${lRatio} - 0.5px)`;\r\n        this.leftNode.element.style.maxWidth = `calc(${this.leftInitMaxWidth} * ${lRatio} - 0.5px)`;\r\n        this.rightNode.element.style.width = `calc(${this.rightInitWidth} * ${rRatio} - 0.5px)`;\r\n        this.rightNode.element.style.maxWidth = `calc(${this.rightInitMaxWidth} * ${rRatio} - 0.5px)`;\r\n    }\r\n    finish() {\r\n        this.resizeInProgress = false;\r\n        this.resetNodeStyles();\r\n        if (this.leftNode) {\r\n            return {\r\n                leftNode: this.leftNode,\r\n                rightNode: this.rightNode,\r\n                shiftRatio: this.deltaX / (this.leftWidth + this.rightWidth)\r\n            };\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    highlightResizedNode() {\r\n        this.leftNode.element.classList.add(\"xaf-layouteditor-resized-item\");\r\n        this.rightNode.element.classList.add(\"xaf-layouteditor-resized-item\");\r\n    }\r\n    resetNodeStyles() {\r\n        this.leftNode.element.style.width = \"\";\r\n        this.leftNode.element.style.maxWidth = \"\";\r\n        this.leftNode.element.classList.remove(\"xaf-layouteditor-resized-item\");\r\n        this.rightNode.element.style.width = \"\";\r\n        this.rightNode.element.style.maxWidth = \"\";\r\n        this.rightNode.element.classList.remove(\"xaf-layouteditor-resized-item\");\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./Scripts/LayoutEditor/resizing.ts?");

/***/ }),

/***/ "./Scripts/alert.ts":
/*!**************************!*\
  !*** ./Scripts/alert.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ alert)\n/* harmony export */ });\nclass alert {\r\n    constructor() {\r\n        this.userDuration = 3000;\r\n        this.disableScrollRequestsCount = 0;\r\n    }\r\n    onElementRemovedFromDOM(element, callback) {\r\n        let parent = element.parentNode, mutationObserver = new MutationObserver(mutations => {\r\n            mutations.forEach(mutation => {\r\n                mutation.removedNodes.forEach(node => {\r\n                    if (node === element) {\r\n                        mutationObserver.disconnect();\r\n                        callback();\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        mutationObserver.observe(parent, {\r\n            childList: true,\r\n        });\r\n        element.disconnectRemovedFromDomObserver = function () {\r\n            mutationObserver.disconnect();\r\n        };\r\n    }\r\n    toggleScrolling(enabled) {\r\n        enabled ? this.disableScrollRequestsCount-- : this.disableScrollRequestsCount++;\r\n        const scrollContainer = document.querySelector(\".xaf-alerts-stack-scrollable\");\r\n        scrollContainer.classList.toggle(\"scrolling-enabled\", this.disableScrollRequestsCount === 0);\r\n    }\r\n    addAnimationEndEventListener(element, animationEndEvent) {\r\n        if (element.animationEndCallback) {\r\n            element.animationEndCallback();\r\n        }\r\n        element.animationEndCallback = animationEndEvent;\r\n        this.onElementRemovedFromDOM(element, animationEndEvent);\r\n        element.addEventListener('animationend', animationEndEvent);\r\n    }\r\n    removeAnimationEndEventListener(element, animationEndEvent) {\r\n        delete element.animationEndCallback;\r\n        if (element.disconnectRemovedFromDomObserver) {\r\n            element.disconnectRemovedFromDomObserver();\r\n        }\r\n        element.removeEventListener('animationend', animationEndEvent);\r\n    }\r\n    addAnimation(element, visible) {\r\n        element.classList.add(\"show\");\r\n        element.classList.toggle(\"showing\", visible);\r\n        element.classList.toggle(\"hiding\", !visible);\r\n    }\r\n    removeAnimation(element, visible) {\r\n        element.classList.toggle(\"show\", visible);\r\n        element.classList.remove(\"showing\");\r\n        element.classList.remove(\"hiding\");\r\n    }\r\n    getAlerts(postSelector) {\r\n        var postSelectorString = postSelector ? postSelector : \"\";\r\n        return Array.from(document.querySelectorAll(\".xaf-alerts-stack .xaf-alert\" + postSelectorString));\r\n    }\r\n    addAnimationToAlreadyDisplayedAlerts(element, visible) {\r\n        const alerts = this.getAlerts(\":not(.xaf-alert-summary)\");\r\n        alerts.forEach((alert, index) => {\r\n            if (alert === element) {\r\n                return;\r\n            }\r\n            var animationEndEvent = () => {\r\n                alert.classList.remove(\"showing\");\r\n                alert.classList.remove(\"moving-down\");\r\n                this.removeAnimationEndEventListener(alert, animationEndEvent);\r\n            };\r\n            var addAnimationToAlert = (animationName) => {\r\n                this.addAnimationEndEventListener(alert, animationEndEvent);\r\n                alert.classList.add(animationName);\r\n            };\r\n            if (visible) {\r\n                addAnimationToAlert(\"showing\");\r\n            }\r\n            else if (!alert.classList.contains(\"hiding\")) {\r\n                if (index < alerts.indexOf(element) || element.classList.contains(\"xaf-alert-summary\")) {\r\n                    addAnimationToAlert(\"moving-down\");\r\n                }\r\n            }\r\n        });\r\n    }\r\n    setVisible(element, visible, animateOnlyTargetElement) {\r\n        this.toggleScrolling(false);\r\n        if (!visible && this.timeoutId) {\r\n            clearTimeout(this.timeoutId);\r\n            delete this.timeoutId;\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            var animationEndEvent = (e) => {\r\n                this.removeAnimation(element, visible);\r\n                this.removeAnimationEndEventListener(element, animationEndEvent);\r\n                this.toggleScrolling(true);\r\n                if (!e) {\r\n                    reject();\r\n                }\r\n                else {\r\n                    resolve(undefined);\r\n                }\r\n            };\r\n            this.addAnimationEndEventListener(element, animationEndEvent);\r\n            this.addAnimation(element, visible);\r\n            if (!animateOnlyTargetElement) {\r\n                this.addAnimationToAlreadyDisplayedAlerts(element, visible);\r\n            }\r\n        });\r\n    }\r\n    autoCloseAlerts(duration) {\r\n        this.userDuration = duration;\r\n        if (window.xaf.device.isMobile()) {\r\n            return;\r\n        }\r\n        clearTimeout(this.timeoutId);\r\n        this.timeoutId = setTimeout(() => {\r\n            var closeAllButton = document.querySelector(\".xaf-alerts-stack:not(.xaf-alerts-stack-no-limit-count) #xaf-alert-summary-close-all-button\");\r\n            if (closeAllButton) {\r\n                closeAllButton.click();\r\n            }\r\n            delete this.timeoutId;\r\n        }, duration);\r\n    }\r\n    closeAlerts() {\r\n        var alertsToClose = this.getAlerts(\":not(.xaf-alert-summary)\");\r\n        return Promise.all(alertsToClose.map(alert => this.setVisible(alert, false, true)));\r\n    }\r\n    initAlertButton(button) {\r\n        button === null || button === void 0 ? void 0 : button.addEventListener(\"click\", (event) => {\r\n            if (event.target instanceof HTMLElement) {\r\n                event.target.closest(\".xaf-alert-settings-container\").classList.toggle(\"hover\");\r\n            }\r\n        });\r\n    }\r\n    initAlertHandlers(alertStackInner) {\r\n        alertStackInner === null || alertStackInner === void 0 ? void 0 : alertStackInner.addEventListener(\"mouseenter\", (event) => {\r\n            clearTimeout(this.timeoutId);\r\n            delete this.timeoutId;\r\n        });\r\n        alertStackInner === null || alertStackInner === void 0 ? void 0 : alertStackInner.addEventListener(\"mouseleave\", (event) => {\r\n            this.autoCloseAlerts(this.userDuration);\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/alert.ts?");

/***/ }),

/***/ "./Scripts/app.ts":
/*!************************!*\
  !*** ./Scripts/app.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addChildEventListener: () => (/* binding */ addChildEventListener)\n/* harmony export */ });\n/* harmony import */ var _xafNavigationClickHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./xafNavigationClickHelper */ \"./Scripts/xafNavigationClickHelper.ts\");\n/* harmony import */ var _confirmUnsavedChangesController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./confirmUnsavedChangesController */ \"./Scripts/confirmUnsavedChangesController.ts\");\n/* harmony import */ var _createDropDownPositionController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createDropDownPositionController */ \"./Scripts/createDropDownPositionController.ts\");\n/* harmony import */ var _closeOutsideClickController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./closeOutsideClickController */ \"./Scripts/closeOutsideClickController.ts\");\n/* harmony import */ var _themeService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./themeService */ \"./Scripts/themeService.ts\");\n/* harmony import */ var _uploadComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./uploadComponent */ \"./Scripts/uploadComponent.ts\");\n/* harmony import */ var _imageComponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./imageComponent */ \"./Scripts/imageComponent.ts\");\n/* harmony import */ var _device__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./device */ \"./Scripts/device.ts\");\n/* harmony import */ var _alert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./alert */ \"./Scripts/alert.ts\");\n/* harmony import */ var _progressbar__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./progressbar */ \"./Scripts/progressbar.ts\");\n/* harmony import */ var _errorPageObserver__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./errorPageObserver */ \"./Scripts/errorPageObserver.ts\");\n/* harmony import */ var _easyTest__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./easyTest */ \"./Scripts/easyTest.ts\");\n/* harmony import */ var _loadingIndicator__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./loadingIndicator */ \"./Scripts/loadingIndicator.ts\");\n/* harmony import */ var _resizeObserverUtils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./resizeObserverUtils */ \"./Scripts/resizeObserverUtils.ts\");\n/* harmony import */ var _report__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./report */ \"./Scripts/report.ts\");\n/* harmony import */ var _LayoutEditor_layout_editor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./LayoutEditor/layout-editor */ \"./Scripts/LayoutEditor/layout-editor.ts\");\n/* harmony import */ var _filterBuilder__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./filterBuilder */ \"./Scripts/filterBuilder.ts\");\n/* harmony import */ var _fileDataEditor__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./fileDataEditor */ \"./Scripts/fileDataEditor.ts\");\n/* harmony import */ var _outsideClickComponent__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./outsideClickComponent */ \"./Scripts/outsideClickComponent.ts\");\n/* harmony import */ var _splitter__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./splitter */ \"./Scripts/splitter.ts\");\n/* harmony import */ var _xafContextMenuClickHelper__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./xafContextMenuClickHelper */ \"./Scripts/xafContextMenuClickHelper.ts\");\n/* harmony import */ var _loadingPanelObserver__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./loadingPanelObserver */ \"./Scripts/loadingPanelObserver.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst _report = new _report__WEBPACK_IMPORTED_MODULE_14__[\"default\"]();\r\nconst _loadingPanelObserver = new _loadingPanelObserver__WEBPACK_IMPORTED_MODULE_21__[\"default\"]();\r\n_loadingPanelObserver.runObserver();\r\nconst _errorPageObserver = new _errorPageObserver__WEBPACK_IMPORTED_MODULE_10__[\"default\"]();\r\n_errorPageObserver.runObserver();\r\nconst apiFacade = {\r\n    device: new _device__WEBPACK_IMPORTED_MODULE_7__[\"default\"](),\r\n    ConfirmUnsavedChangesController: new _confirmUnsavedChangesController__WEBPACK_IMPORTED_MODULE_1__[\"default\"](),\r\n    createDropDownPositionController: _createDropDownPositionController__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\r\n    closeOutsideClickController: new _closeOutsideClickController__WEBPACK_IMPORTED_MODULE_3__[\"default\"](),\r\n    themeService: new _themeService__WEBPACK_IMPORTED_MODULE_4__[\"default\"](),\r\n    uploadComponent: new _uploadComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"](),\r\n    imageComponent: new _imageComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"](),\r\n    alert: new _alert__WEBPACK_IMPORTED_MODULE_8__[\"default\"](),\r\n    getColumnChooserTargetSelector: getColumnChooserTargetSelector,\r\n    focusViewItem: focusViewItem,\r\n    focusToolbarAction,\r\n    closeSideBarIfMobile: closeSideBarIfMobile,\r\n    toggleSideBar: toggleSideBar,\r\n    setStopPropagationHandler: setStopPropagationHandler,\r\n    bindButtonToContainer: bindButtonToContainer,\r\n    initApplicationWindowTemplate: initApplicationWindowTemplate,\r\n    resetMainContentScrollPosition: resetMainContentScrollPosition,\r\n    registerErrorButtonHandlers: _errorPageObserver.registerErrorButtonHandlers,\r\n    registerErrorButtonHandlersForPopup: registerErrorButtonHandlersForPopup,\r\n    setPageTitle: setPageTitle,\r\n    setLangAttribute: setLangAttribute,\r\n    initLightModeObjectLink: initLightModeObjectLink,\r\n    easytest: new _easyTest__WEBPACK_IMPORTED_MODULE_11__[\"default\"](),\r\n    progressBar: new _progressbar__WEBPACK_IMPORTED_MODULE_9__[\"default\"](),\r\n    loadingIndicator: new _loadingIndicator__WEBPACK_IMPORTED_MODULE_12__[\"default\"](),\r\n    resizeObserverUtils: new _resizeObserverUtils__WEBPACK_IMPORTED_MODULE_13__[\"default\"](),\r\n    reportViewerCreated: _report.reportViewerCreated.bind(_report),\r\n    reportViewerDestroyed: _report.reportViewerDestroyed.bind(_report),\r\n    nativeReportViewerCreated: _report.nativeReportViewerCreated.bind(_report),\r\n    nativeReportViewerDestroyed: _report.nativeReportViewerDestroyed.bind(_report),\r\n    onBeforeRenderReportDesigner: _report.onBeforeRenderReportDesigner.bind(_report),\r\n    onCustomizeMenuActionsReportDesigner: _report.onCustomizeMenuActionsReportDesigner.bind(_report),\r\n    setHiddenReportDesignerActions: _report.setHiddenReportDesignerActions.bind(_report),\r\n    onBeforeRenderReportViewer: _report.onBeforeRenderReportViewer.bind(_report),\r\n    setIsNewReport: _report.setIsNewReport.bind(_report),\r\n    setParametersTypes: _report.setParametersTypes.bind(_report),\r\n    setDxReportDesignerContainerReference: _report.setDxReportDesignerContainerReference.bind(_report),\r\n    settingsComponent: new _outsideClickComponent__WEBPACK_IMPORTED_MODULE_18__.settingsComponent(),\r\n    accountComponent: new _outsideClickComponent__WEBPACK_IMPORTED_MODULE_18__.accountComponent(),\r\n    layoutEditor: _LayoutEditor_layout_editor__WEBPACK_IMPORTED_MODULE_15__,\r\n    filterEditor: _filterBuilder__WEBPACK_IMPORTED_MODULE_16__[\"default\"],\r\n    fileDataEditor: _fileDataEditor__WEBPACK_IMPORTED_MODULE_17__[\"default\"],\r\n    splitter: _splitter__WEBPACK_IMPORTED_MODULE_19__,\r\n    loadingPanelObserver: _loadingPanelObserver\r\n};\r\nwindow.xaf = apiFacade;\r\ncustomElements.define(\"xaf-navigation-click-helper\", _xafNavigationClickHelper__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\r\ncustomElements.define(\"xaf-contextmenu-click-helper\", _xafContextMenuClickHelper__WEBPACK_IMPORTED_MODULE_20__[\"default\"]);\r\nsetBrowser();\r\nfunction processGroup(element) {\r\n    var btnGroup = element.closest('.btn-group');\r\n    if (btnGroup) {\r\n        btnGroup.classList.add('group-has-template');\r\n    }\r\n}\r\nfunction registerErrorButtonHandlersForPopup(view) {\r\n    _errorPageObserver.registerErrorButtonHandlers(getParentElement(view, \"dxbl-modal-content\"));\r\n}\r\n//toolbarObserver\r\nnew MutationObserver(function (mutationsList) {\r\n    mutationsList.forEach(function (mutation) {\r\n        for (let i = 0; i < mutation.addedNodes.length; i++) {\r\n            const node = mutation.addedNodes[i];\r\n            if (node.nodeType === Node.ELEMENT_NODE && node instanceof HTMLElement) {\r\n                if (node.matches('.combobox-xaf-action, .parametrized-action-wrapper')) {\r\n                    processGroup(node);\r\n                }\r\n                const elements = node.querySelectorAll('.combobox-xaf-action, .parametrized-action-wrapper');\r\n                for (let j = 0; j < elements.length; j++) {\r\n                    processGroup(elements[j]);\r\n                }\r\n            }\r\n        }\r\n        ;\r\n    });\r\n}).observe(document.body, { childList: true, subtree: true });\r\n//check reconnection\r\nnew MutationObserver(() => {\r\n    const reconnectModalElement = document.querySelector('body > #components-reconnect-modal');\r\n    if (reconnectModalElement) {\r\n        const shadowRoot = reconnectModalElement.shadowRoot;\r\n        if (shadowRoot) {\r\n            const reconnectDialog = shadowRoot.querySelector('.components-reconnect-dialog');\r\n            if (reconnectDialog) {\r\n                reconnectDialog.style.backgroundColor = \"rgb(var(--bs-dark-rgb))\";\r\n            }\r\n            const paragraph = shadowRoot.querySelector('.components-reconnect-dialog p');\r\n            if (paragraph) {\r\n                paragraph.style.color = \"rgb(var(--bs-white-rgb))\";\r\n            }\r\n            const button = shadowRoot.querySelector('.components-reconnect-dialog button');\r\n            if (button) {\r\n                button.style.backgroundColor = \"var(--bs-primary)\";\r\n            }\r\n        }\r\n        else {\r\n            reconnectModalElement.classList.add(\"bg-dark\", \"text-white\");\r\n            const reloadingLink = document.querySelector('#components-reconnect-modal a');\r\n            if (reloadingLink) {\r\n                reloadingLink.classList.add(\"text-primary\");\r\n            }\r\n            const retryButton = document.querySelector('#components-reconnect-modal button');\r\n            if (retryButton) {\r\n                retryButton.classList.add(\"btn\", \"btn-primary\", \"shadow-none\");\r\n            }\r\n        }\r\n    }\r\n}).observe(document.body, { childList: true, subtree: true });\r\ndocument.addEventListener(\"keypress\", function (e) {\r\n    if (e.target instanceof HTMLElement && e.target.tagName.toLowerCase() === 'input' && e.keyCode === 13 && !window.xaf.loadingIndicator.isShowing()) {\r\n        const primaryItem = document.querySelector('.logon-toolbar .dxbl-toolbar .dxbl-btn.dxbl-btn-primary');\r\n        if (primaryItem) {\r\n            e.target.blur();\r\n            setTimeout(() => { primaryItem.click(); });\r\n        }\r\n    }\r\n});\r\nfunction getColumnChooserTargetSelector(columnChooserToolbarItemCssClass) {\r\n    const toolbarItemSelector = '.' + columnChooserToolbarItemCssClass;\r\n    const toolbarItem = document.querySelector(toolbarItemSelector);\r\n    if (toolbarItem) {\r\n        const itemIsHidden = getComputedStyle(toolbarItem).display === 'none';\r\n        if (itemIsHidden) {\r\n            const toolbar = toolbarItem.closest('.dxbl-toolbar');\r\n            const ag = toolbar.querySelector('.dxbl-toolbar-btn-ellipsis');\r\n            const ellipsisAttribute = ag.getAttributeNode(\"data-dxtoolbar-ellipsis-dropdown-id\");\r\n            return '[' + ellipsisAttribute.name + '=\"' + ellipsisAttribute.value + '\"]';\r\n        }\r\n    }\r\n    return toolbarItemSelector;\r\n}\r\nfunction focusViewItem(caption) {\r\n    caption = caption && caption.replace ? caption.replace(/\\\\/g, \"\\\\\\\\\").replace(/'/g, \"\\\\'\") : caption;\r\n    let selector = \"div[data-item-name='\" + caption + \"'] ~ * input, div[data-item-name='\" + caption + \"'] ~ * textarea\";\r\n    return focusElement(() => selector, \"dxbl-fl\", \"dxbl-fl-loading\");\r\n}\r\nfunction focusToolbarAction(actionSelector) {\r\n    return focusElement(() => actionSelector, \"dxbl-toolbar\", \"dxbl-loading\");\r\n}\r\nfunction focusElement(getSelector, parentCssClass, parentLoadingCssClass) {\r\n    if (!window.xaf.device.isTouchDevice()) {\r\n        const focusedElement = querySelectLastOf(getSelector());\r\n        if (!focusedElement)\r\n            return;\r\n        let parent = getParentElement(focusedElement, parentCssClass);\r\n        if (parent) {\r\n            setDelayedFocus(focusedElement, parent, parentLoadingCssClass);\r\n        }\r\n    }\r\n}\r\nfunction getParentElement(element, parentCssClass) {\r\n    let parent = element;\r\n    while (parent && !parent.classList.contains(parentCssClass)) {\r\n        parent = parent.parentElement;\r\n    }\r\n    return parent;\r\n}\r\nfunction setDelayedFocus(focusedElement, parentElement, parentLoadingCssClass) {\r\n    const callback = () => {\r\n        focusedElement.focus();\r\n        focusedElement.scrollIntoView({ block: \"center\" });\r\n    };\r\n    const delayedCondition = () => document.getElementById('applicationLoadingPanel') || (parentElement && parentLoadingCssClass && parentElement.classList.contains(parentLoadingCssClass));\r\n    if (delayedCondition()) {\r\n        const intervalId = setInterval(() => {\r\n            if (!delayedCondition()) {\r\n                clearInterval(intervalId);\r\n                setTimeout(callback, 0);\r\n            }\r\n        }, 0);\r\n    }\r\n    else {\r\n        setTimeout(callback, 0);\r\n    }\r\n}\r\nfunction querySelectLastOf(selector) {\r\n    const primaryItems = document.querySelectorAll(selector);\r\n    if (primaryItems.length >= 1) {\r\n        return primaryItems[primaryItems.length - 1];\r\n    }\r\n    return null;\r\n}\r\nfunction toggleSideBar() {\r\n    const app = document.getElementsByClassName(\"app\")[0];\r\n    app.classList.toggle(\"collapse-toggle\");\r\n    toggleHamburgerTitle(app);\r\n}\r\nfunction toggleHamburgerTitle(app) {\r\n    const hamburgerBtn = document.querySelector(\".btn-hamburger\");\r\n    if (app && hamburgerBtn) {\r\n        const labelForVisibleNav = hamburgerBtn.dataset.visibleLabel || \"\";\r\n        const labelForHiddenNav = hamburgerBtn.dataset.hiddenLabel || \"\";\r\n        if (app.classList.contains(\"collapse-toggle\")) {\r\n            hamburgerBtn.setAttribute(\"title\", labelForHiddenNav);\r\n            hamburgerBtn.setAttribute(\"aria-label\", labelForHiddenNav);\r\n        }\r\n        else {\r\n            hamburgerBtn.setAttribute(\"title\", labelForVisibleNav);\r\n            hamburgerBtn.setAttribute(\"aria-label\", labelForVisibleNav);\r\n        }\r\n    }\r\n}\r\nfunction closeSideBarIfMobile() {\r\n    if (window.xaf.device.isMobile()) {\r\n        var app = document.getElementsByClassName(\"app\")[0];\r\n        app.classList.remove(\"collapse-toggle\");\r\n        toggleHamburgerTitle(app);\r\n    }\r\n}\r\nfunction setStopPropagationHandler(element) {\r\n    if (element instanceof HTMLElement) {\r\n        element.addEventListener(\"click\", (ev) => ev.stopPropagation());\r\n    }\r\n}\r\nfunction bindButtonToContainer(id) {\r\n    const buttonElement = document.getElementById(id);\r\n    const input = buttonElement.closest('.parametrized-action-wrapper').querySelector(\"input\");\r\n    if (input) {\r\n        input.addEventListener(\"keypress\", (args) => {\r\n            if (args.key === 'Enter') {\r\n                input.blur();\r\n                setTimeout(function () {\r\n                    // find the buttonElement again because the element reference might be stale\r\n                    const buttonElement = document.getElementById(id);\r\n                    buttonElement.focus();\r\n                    buttonElement.click();\r\n                    input.focus();\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction initApplicationWindowTemplate() {\r\n    var _a, _b;\r\n    const SKIP_LINK_ID = 'skip-navigation-link';\r\n    const TARGET_ELEMENT_ID = 'main-view-content';\r\n    (_a = document.querySelector(\".btn-hamburger\")) === null || _a === void 0 ? void 0 : _a.addEventListener(\"click\", (ev) => toggleSideBar());\r\n    (_b = document.querySelector(\".sidebar-sm-shadow\")) === null || _b === void 0 ? void 0 : _b.addEventListener(\"click\", (ev) => toggleSideBar());\r\n    toggleHamburgerTitle(document.getElementsByClassName(\"app\")[0]);\r\n    const skipLink = document.getElementById(SKIP_LINK_ID);\r\n    skipLink && skipLink.addEventListener('click', e => {\r\n        var _a;\r\n        e.preventDefault();\r\n        (_a = document.getElementById(TARGET_ELEMENT_ID)) === null || _a === void 0 ? void 0 : _a.focus();\r\n    });\r\n}\r\nfunction resetMainContentScrollPosition() {\r\n    // for T1113652 -- prevent resetting scroll that has been set for the default focused item\r\n    const InputTagList = ['input', 'textarea', 'button', 'select'];\r\n    if (InputTagList.indexOf(document.activeElement.tagName.toLowerCase()) === -1) {\r\n        var mainContent = document.getElementsByClassName(\"main-content\")[0];\r\n        if (mainContent) {\r\n            mainContent.scrollTop = 0;\r\n            mainContent.scrollLeft = 0;\r\n        }\r\n    }\r\n}\r\nfunction setPageTitle(title) {\r\n    document.title = title;\r\n}\r\nfunction setLangAttribute(lang) {\r\n    document.documentElement.lang = lang;\r\n}\r\nfunction initLightModeObjectLink(element, dotNetHelper) {\r\n    var openNewTab = async function () {\r\n        let newWindow = window.open(\"about:blank\", \"_blank\");\r\n        if (newWindow) {\r\n            let url = await dotNetHelper.invokeMethodAsync(\"GetCurrentUrl\");\r\n            newWindow.location = url;\r\n        }\r\n    };\r\n    element === null || element === void 0 ? void 0 : element.addEventListener(\"click\", async (ev) => {\r\n        ev.preventDefault();\r\n        ev.stopPropagation();\r\n        if (ev.ctrlKey) {\r\n            openNewTab();\r\n        }\r\n        else {\r\n            await dotNetHelper.invokeMethodAsync(\"SimpleClick\");\r\n        }\r\n    });\r\n    element === null || element === void 0 ? void 0 : element.addEventListener(\"auxclick\", async (ev) => {\r\n        ev.preventDefault();\r\n        if (ev.button === 1) {\r\n            openNewTab();\r\n        }\r\n    });\r\n}\r\nfunction addChildEventListener(base, eventName, selector, handler, canHandleEvent) {\r\n    base.addEventListener(eventName, (event) => {\r\n        if (!(event.target instanceof Element))\r\n            return;\r\n        const closest = event.target.closest(selector);\r\n        if (closest && base.contains(closest)) {\r\n            const isDisabledButton = closest instanceof HTMLButtonElement && (closest.disabled || closest.classList.contains('dxbl-disabled'));\r\n            if (isDisabledButton) {\r\n                return;\r\n            }\r\n            if (canHandleEvent(event)) {\r\n                handler.call(closest, event);\r\n            }\r\n            return;\r\n        }\r\n    });\r\n}\r\nfunction setBrowser() {\r\n    let getBrowserName = function (agent) {\r\n        switch (true) {\r\n            case agent.indexOf(\"edg\") > -1: return \"edge\";\r\n            case agent.indexOf(\"chrome\") > -1: return \"chrome\";\r\n            case agent.indexOf(\"firefox\") > -1: return \"firefox\";\r\n            case agent.indexOf(\"safari\") > -1: return \"safari\";\r\n            default: \"\";\r\n        }\r\n    };\r\n    let agent = typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';\r\n    ``;\r\n    let browserName = getBrowserName(agent);\r\n    if (browserName) {\r\n        document.documentElement.classList.add(`xaf-${browserName}`);\r\n    }\r\n}\r\nconst SINGLE_CLICK_LOADING_INDICATOR_TRIGGER_SELECTORS = [\r\n    \".xaf-action:not(.dxbl-disabled)\",\r\n    \".dxbl-listbox-item:not(.dxbl-listbox-item-selected) .xaf-combobox-action\",\r\n    \"[data-xaf-action] > button:first-child\",\r\n    \"button[data-xaf-action]\",\r\n    \".xafPopup:not(.xaf-popup-dialog) button[data-qa-selector='dx-popup-close-button']\",\r\n    \".xaf-close-tab-button\",\r\n    \".xaf-tabbed-mdi .dxbl-tabs-item:has(.xaf-tab-header-template-clickable):not(.dxbl-active)\"\r\n];\r\naddChildEventListener(document.querySelector(\"body\"), \"click\", SINGLE_CLICK_LOADING_INDICATOR_TRIGGER_SELECTORS.join(\", \"), () => {\r\n    window.xaf.loadingIndicator.show();\r\n    return false;\r\n}, (event) => event.composedPath().find(e => e instanceof HTMLElement && (e.classList.contains('no-loading-indicator') || e.classList.contains('dxbl-grid-tree-node-expand-button'))) === undefined);\r\naddChildEventListener(document.querySelector(\"body\"), \"dblclick\", \".xaf-double-click\", () => {\r\n    window.xaf.loadingIndicator.show();\r\n    return false;\r\n}, (event) => event.composedPath().find(e => e instanceof HTMLElement && e.classList.contains('no-loading-indicator')) === undefined);\r\nwindow.addEventListener(\"online\", function () {\r\n    window.xaf.loadingIndicator.hide();\r\n});\r\n\n\n//# sourceURL=webpack:///./Scripts/app.ts?");

/***/ }),

/***/ "./Scripts/closeOutsideClickController.ts":
/*!************************************************!*\
  !*** ./Scripts/closeOutsideClickController.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ closeOutsideClickController)\n/* harmony export */ });\nclass closeOutsideClickController {\r\n    getMainElement(id) {\r\n        return document.getElementById(id);\r\n    }\r\n    getShadowElement(shadow) {\r\n        return typeof shadow === \"string\" ? document.querySelector(shadow) : shadow;\r\n    }\r\n    removeGlobalClickHandler(element) {\r\n        if (element === null || element === void 0 ? void 0 : element.GlobalClickHandler) {\r\n            document.removeEventListener(\"pointerdown\", element.GlobalClickHandler);\r\n            delete element.GlobalClickHandler;\r\n        }\r\n    }\r\n    addGlobalClickHandler(element, callback) {\r\n        element.GlobalClickHandler = (e) => {\r\n            if (e.target instanceof HTMLElement) {\r\n                var dropdown = e.target.closest(\"dxbl-dropdown\");\r\n                if (element === e.target || !(element.contains(e.target) || (dropdown && element.contains(dropdown.placementTargetElement)))) {\r\n                    callback(e);\r\n                }\r\n            }\r\n        };\r\n        document.addEventListener(\"pointerdown\", element.GlobalClickHandler);\r\n    }\r\n    isVisible(id) {\r\n        return this.getMainElement(id).classList.contains('show-dropdown');\r\n    }\r\n    toggle(id, shadow) {\r\n        this.isVisible(id) ? this.hide(id) : this.show(id, shadow);\r\n    }\r\n    show(id, shadow) {\r\n        const mainElement = this.getMainElement(id);\r\n        const shadowElement = this.getShadowElement(shadow);\r\n        this.addGlobalClickHandler(mainElement, (e) => {\r\n            if (e.target instanceof HTMLElement && !shadowElement.contains(e.target)) {\r\n                this.hide(id);\r\n            }\r\n        });\r\n        mainElement.classList.add('show-dropdown');\r\n    }\r\n    hide(id) {\r\n        var mainElement = this.getMainElement(id);\r\n        if (!mainElement)\r\n            return;\r\n        this.removeGlobalClickHandler(mainElement);\r\n        mainElement.classList.remove('show-dropdown');\r\n        if (mainElement._onhide) {\r\n            mainElement._onhide();\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/closeOutsideClickController.ts?");

/***/ }),

/***/ "./Scripts/confirmUnsavedChangesController.ts":
/*!****************************************************!*\
  !*** ./Scripts/confirmUnsavedChangesController.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ confirmUnsavedChangesController)\n/* harmony export */ });\nclass confirmUnsavedChangesController {\r\n    constructor() {\r\n        this.boundOnCustomOnBeforeUnload = this.CustomOnBeforeUnload.bind(this);\r\n        this._isModified = false;\r\n        window.addEventListener(\"beforeunload\", this.boundOnCustomOnBeforeUnload, false);\r\n    }\r\n    SetModified(isModified) {\r\n        this._isModified = isModified;\r\n    }\r\n    CustomOnBeforeUnload(e) {\r\n        if (this.IsModified()) {\r\n            e.returnValue = false;\r\n            return false;\r\n        }\r\n    }\r\n    IsModified() {\r\n        return this._isModified;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/confirmUnsavedChangesController.ts?");

/***/ }),

/***/ "./Scripts/createDropDownPositionController.ts":
/*!*****************************************************!*\
  !*** ./Scripts/createDropDownPositionController.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ createDropDownPositionController)\n/* harmony export */ });\nclass createDropDownPositionController {\r\n    constructor(dropDownElement, sourceElement) {\r\n        const sourceElementBottom = parseFloat(getComputedStyle(sourceElement).bottom);\r\n        const dropDownBottom = sourceElement.scrollHeight + 1.5 * sourceElementBottom;\r\n        const intersectedDropDownBottom = 0.5 * sourceElementBottom - dropDownElement.scrollHeight;\r\n        const markerElement = document.createElement(\"div\");\r\n        markerElement.style.position = \"absolute\";\r\n        markerElement.style.bottom = `${dropDownElement.scrollHeight + dropDownBottom - 12}px`; // 12 is padding from .xaf-image-menu-content\r\n        dropDownElement.parentElement.appendChild(markerElement);\r\n        dropDownElement.style.right = getComputedStyle(sourceElement).right;\r\n        dropDownElement._observer = new IntersectionObserver(entries => {\r\n            let entry = entries[0];\r\n            if (entry.target === markerElement) {\r\n                dropDownElement.style.bottom = `${!entry.isIntersecting ? intersectedDropDownBottom : dropDownBottom}px`;\r\n            }\r\n        });\r\n        dropDownElement._observer.observe(markerElement);\r\n        dropDownElement._onhide = () => {\r\n            if (dropDownElement._observer) {\r\n                dropDownElement.parentElement.removeChild(markerElement);\r\n                dropDownElement._observer.disconnect();\r\n                delete dropDownElement._observer;\r\n                delete dropDownElement._onhide;\r\n            }\r\n        };\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/createDropDownPositionController.ts?");

/***/ }),

/***/ "./Scripts/device.ts":
/*!***************************!*\
  !*** ./Scripts/device.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ device)\n/* harmony export */ });\nclass device {\r\n    isMobile() {\r\n        return innerWidth <= 576;\r\n    }\r\n    isTouchDevice() {\r\n        try {\r\n            document.createEvent(\"TouchEvent\");\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/device.ts?");

/***/ }),

/***/ "./Scripts/easyTest.ts":
/*!*****************************!*\
  !*** ./Scripts/easyTest.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ easyTest)\n/* harmony export */ });\nclass easyTest {\r\n    constructor() {\r\n        this._dataReceivedCallCount = 0;\r\n        this._currentID = '';\r\n    }\r\n    start() {\r\n        this._currentID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n            var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\r\n            return v.toString(16);\r\n        });\r\n        this.dataReceiveObserver = new MutationObserver(() => {\r\n            this._dataReceivedCallCount++;\r\n        });\r\n        this.dataReceiveObserver.observe(document.body, { childList: true, subtree: true });\r\n        return this._currentID;\r\n    }\r\n    stop() {\r\n        if (this.dataReceiveObserver) {\r\n            this.dataReceiveObserver.disconnect();\r\n            this.dataReceiveObserver = undefined;\r\n        }\r\n    }\r\n    get dataReceivedCallCount() { return this._dataReceivedCallCount; }\r\n    get currentId() { return this._currentID; }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/easyTest.ts?");

/***/ }),

/***/ "./Scripts/errorPageObserver.ts":
/*!**************************************!*\
  !*** ./Scripts/errorPageObserver.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ errorPageObserver)\n/* harmony export */ });\nclass errorPageObserver {\r\n    toogleDetailedErrorDescription() {\r\n        const detailedError = document.getElementById(\"error-detailed\");\r\n        if (detailedError) {\r\n            detailedError.style.maxHeight = detailedError.style.maxHeight ? \"\" : (detailedError.scrollHeight + 2) + \"px\";\r\n            detailedError.classList.toggle(\"show\");\r\n        }\r\n    }\r\n    getErrorPage() {\r\n        return document.getElementById(\"xaf-error-page\");\r\n    }\r\n    registerErrorButtonHandlers(errorPage) {\r\n        const refreshButton = errorPage.querySelector(\".error-btn-refresh\");\r\n        if (refreshButton instanceof HTMLElement) {\r\n            refreshButton.addEventListener(\"click\", (ev) => window.location.reload());\r\n        }\r\n        const copyDetailsButton = errorPage.querySelector(\".error-btn-copy-details\");\r\n        if (copyDetailsButton instanceof HTMLElement) {\r\n            copyDetailsButton.addEventListener(\"click\", (ev) => this.copyErrorDetailsToClipboard(errorPage));\r\n        }\r\n    }\r\n    copyErrorDetailsToClipboard(errorPage) {\r\n        const errorDetails = errorPage.querySelector(\".error-detailed\");\r\n        if (errorDetails) {\r\n            navigator.clipboard.writeText(errorDetails.innerText);\r\n        }\r\n    }\r\n    runObserver() {\r\n        var errorPage = this.getErrorPage();\r\n        if (!!errorPage) {\r\n            this.registerErrorButtonHandlers(errorPage);\r\n        }\r\n        else {\r\n            new MutationObserver((mutationsList, observer) => {\r\n                var errorPage = this.getErrorPage();\r\n                if (!!errorPage) {\r\n                    observer.disconnect();\r\n                    this.registerErrorButtonHandlers(errorPage);\r\n                }\r\n            }).observe(document.body, { childList: true, subtree: true });\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/errorPageObserver.ts?");

/***/ }),

/***/ "./Scripts/fileDataEditor.ts":
/*!***********************************!*\
  !*** ./Scripts/fileDataEditor.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _uploadComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uploadComponent */ \"./Scripts/uploadComponent.ts\");\n\r\nconst store = {};\r\nconst showFileDialog = (uploadElementId) => {\r\n    const uc = new _uploadComponent__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    if (uc.canShowFileDialog(uploadElementId)) {\r\n        uc.open(uploadElementId);\r\n    }\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\r\n    Init: (options, dotnetHelper) => {\r\n        store[options.inputId] = {\r\n            dotNetReference: dotnetHelper,\r\n            attachmentButtonId: options.attachmentButtonId,\r\n            uploadElementId: options.uploadElementId,\r\n            isFileDataEmpty: options.isFileDataEmpty,\r\n            isModified: options.isModified\r\n        };\r\n        const input = document.getElementById(options.inputId);\r\n        const attachmentButton = document.getElementById(options.attachmentButtonId);\r\n        input === null || input === void 0 ? void 0 : input.addEventListener(\"click\", async (ev) => {\r\n            const _options = store[options.inputId];\r\n            if (_options.isFileDataEmpty || _options.isModified) {\r\n                showFileDialog(options.uploadElementId);\r\n            }\r\n            else {\r\n                store[options.inputId].dotNetReference.invokeMethodAsync(\"DownloadFile\");\r\n            }\r\n        });\r\n        attachmentButton === null || attachmentButton === void 0 ? void 0 : attachmentButton.addEventListener(\"click\", (ev) => {\r\n            showFileDialog(options.uploadElementId);\r\n        });\r\n    },\r\n    DownloadHandler: (id) => {\r\n        store[id].dotNetReference.invokeMethodAsync(\"DownloadFile\");\r\n    },\r\n    SetParameters: (options) => {\r\n        if (store[options.inputId].isFileDataEmpty !== options.isFileDataEmpty) {\r\n            store[options.inputId].isFileDataEmpty = options.isFileDataEmpty;\r\n        }\r\n        if (store[options.inputId].isModified !== options.isModified) {\r\n            store[options.inputId].isModified = options.isModified;\r\n        }\r\n    },\r\n    DownloadFile: (fileUrl, fileName) => {\r\n        var a = document.createElement('a');\r\n        a.href = fileUrl;\r\n        a.download = fileUrl;\r\n        a.onclick = (event) => event.stopPropagation();\r\n        a.innerText = fileName;\r\n        document.body.appendChild(a);\r\n        a.click();\r\n        document.body.removeChild(a);\r\n    },\r\n    Dispose: (id) => {\r\n        delete store[id];\r\n    }\r\n});\r\n\n\n//# sourceURL=webpack:///./Scripts/fileDataEditor.ts?");

/***/ }),

/***/ "./Scripts/filterBuilder.ts":
/*!**********************************!*\
  !*** ./Scripts/filterBuilder.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst dataBindValue = \"component: { name: \\\"dx-filtereditor-plain\\\", params: { options: options, fieldListProvider: fieldListProvider, displayNameProvider: displayNameProvider }}\";\r\nconst typesCache = {};\r\nconst store = {};\r\nfunction getFunctionFromString(path) {\r\n    let scopeWindow = window;\r\n    path = path.replace(/\\\"/gi, '');\r\n    var items = path.split('.');\r\n    for (var i = 0; i < items.length - 1; i++) {\r\n        scopeWindow = scopeWindow[items[i]];\r\n        if (scopeWindow === undefined)\r\n            return;\r\n    }\r\n    return scopeWindow[items[items.length - 1]];\r\n}\r\nasync function getRealName(id, path, displayName, dotnetHelper) {\r\n    const typeCache = typesCache[store[id].currentType];\r\n    if (!typeCache) {\r\n        return new window.DevExpress.Analytics.Internal.DxDeferred().resolve(displayName).promise();\r\n    }\r\n    const currentTypeCache = typeCache.cacheItems;\r\n    const displayNames = displayName.split(\".\");\r\n    const realNames = [];\r\n    const dfr = new window.DevExpress.Analytics.Internal.DxDeferred();\r\n    let _path = path;\r\n    for (const _displayName of displayNames) {\r\n        const item = await getTypeCache(currentTypeCache, _path, dotnetHelper);\r\n        const cacheItem = item === null || item === void 0 ? void 0 : item.find((i) => i.displayName === _displayName);\r\n        if (cacheItem) {\r\n            _path += _path ? `.${cacheItem.name}` : cacheItem.name;\r\n            realNames.push(cacheItem.name);\r\n        }\r\n        else {\r\n            realNames.push(_displayName);\r\n        }\r\n    }\r\n    dfr.resolve(realNames.join('.'));\r\n    return dfr.promise();\r\n}\r\nasync function getTypeCache(cacheItems, path, dotnetHelper) {\r\n    return new Promise((resolve, reject) => {\r\n        var _a;\r\n        const items = (_a = cacheItems[path]) !== null && _a !== void 0 ? _a : cacheItems[\".\" + path];\r\n        if (items) {\r\n            resolve(items);\r\n        }\r\n        else {\r\n            dotnetHelper.invokeMethodAsync('GetItems', path).then(value => {\r\n                cacheItems[path] = JSON.parse(value);\r\n                resolve(cacheItems[path]);\r\n            });\r\n        }\r\n    });\r\n}\r\nasync function getDisplayName(id, path, propertyName, dotnetHelper) {\r\n    if (!propertyName) {\r\n        return new window.DevExpress.Analytics.Internal.DxDeferred().resolve(\"\").promise();\r\n    }\r\n    const typeCache = typesCache[store[id].currentType];\r\n    if (!typeCache) {\r\n        return new window.DevExpress.Analytics.Internal.DxDeferred().resolve(\"\").promise();\r\n    }\r\n    const currentTypeCache = typeCache.cacheItems;\r\n    const propertyNames = propertyName.split(\".\");\r\n    const displayNames = [];\r\n    const dfr = new window.DevExpress.Analytics.Internal.DxDeferred();\r\n    let cachePath = \"\";\r\n    let usePropertyName = false;\r\n    for (const _propertyName of propertyNames) {\r\n        const item = await getTypeCache(currentTypeCache, path + cachePath, dotnetHelper);\r\n        //const item = currentTypeCache[path + cachePath] ?? currentTypeCache[\".\" + path + cachePath];\r\n        if (!item) {\r\n            usePropertyName = true;\r\n            break;\r\n        }\r\n        const property = item.find((x) => x.name == _propertyName);\r\n        if (!property) {\r\n            usePropertyName = true;\r\n            break;\r\n        }\r\n        displayNames.push(property.displayName);\r\n        cachePath += path || cachePath ? `.${_propertyName}` : _propertyName;\r\n    }\r\n    const result = usePropertyName ? propertyName : displayNames.join('.');\r\n    dfr.resolve(result);\r\n    return dfr.promise();\r\n}\r\nfunction getFilterEditorElement(id) {\r\n    return document.querySelector(`#${id} .filter-editor`);\r\n}\r\nfunction debounce(func, delay) {\r\n    let timeoutId;\r\n    return function (...args) {\r\n        if (timeoutId) {\r\n            clearTimeout(timeoutId);\r\n        }\r\n        timeoutId = setTimeout(() => {\r\n            func.apply(this, args);\r\n        }, delay);\r\n    };\r\n}\r\nfunction getDisplayNameProvider(id, dotnetHelper) {\r\n    return {\r\n        getDisplayNameByPath: function (path, dataMember) {\r\n            const dfr = new window.DevExpress.Analytics.Internal.DxDeferred();\r\n            getDisplayName(id, path, dataMember, dotnetHelper).then(displayName => {\r\n                dfr.resolve(displayName);\r\n            });\r\n            return dfr.promise();\r\n        },\r\n        getRealName: function (path, displayDataMember) {\r\n            const dfr = new window.DevExpress.Analytics.Internal.DxDeferred();\r\n            getRealName(id, path, displayDataMember, dotnetHelper).then(displayName => {\r\n                dfr.resolve(displayName);\r\n            });\r\n            return dfr.promise();\r\n        }\r\n    };\r\n}\r\nfunction getFieldListProvider(id, dotnetHelper) {\r\n    return {\r\n        getItems: function (path) {\r\n            var _a;\r\n            const dfr = new window.DevExpress.Analytics.Internal.DxDeferred();\r\n            if (path.ref === \"Parameters\") {\r\n                dfr.resolve([]);\r\n            }\r\n            else {\r\n                const currentTypeCache = typesCache[_a = store[id].currentType] || (typesCache[_a] = { cacheItems: {}, cacheValues: {} });\r\n                if (!!currentTypeCache.cacheItems[path.fullPath]) {\r\n                    dfr.resolve(currentTypeCache.cacheItems[path.fullPath]);\r\n                }\r\n                else {\r\n                    dotnetHelper.invokeMethodAsync('GetItems', path.fullPath).then(value => {\r\n                        currentTypeCache.cacheItems[path.fullPath] = JSON.parse(value);\r\n                        dfr.resolve(currentTypeCache.cacheItems[path.fullPath]);\r\n                    });\r\n                }\r\n            }\r\n            return dfr.promise();\r\n        },\r\n        getValues: function (path) {\r\n            var _a;\r\n            const dfr = new window.DevExpress.Analytics.Internal.DxDeferred();\r\n            const currentTypeCache = typesCache[_a = store[id].currentType] || (typesCache[_a] = { cacheItems: {}, cacheValues: {} });\r\n            if (!!currentTypeCache.cacheValues[path.fullPath]) {\r\n                dfr.resolve(currentTypeCache.cacheValues[path.fullPath]);\r\n            }\r\n            else {\r\n                dotnetHelper.invokeMethodAsync('GetValues', path.path).then(value => {\r\n                    currentTypeCache.cacheValues[path.fullPath] = JSON.parse(value);\r\n                    dfr.resolve(currentTypeCache.cacheValues[path.fullPath]);\r\n                });\r\n            }\r\n            return dfr.promise();\r\n        }\r\n    };\r\n}\r\nfunction getPopupContainerSelector() {\r\n    const popups = document.querySelectorAll(\"dxbl-modal-dialog\");\r\n    return popups.length ? `#${popups[popups.length - 1].id}` : \"body\";\r\n}\r\nfunction getOptions(id, filterOptions, dotnetHelper) {\r\n    const options = new window.DevExpress.Analytics.Widgets.FilterStringPlainOptions(window.ko.observable(filterOptions.filter));\r\n    options.disabled(filterOptions.disabled);\r\n    options.popupContainer = getPopupContainerSelector();\r\n    options.advancedModePosition = \"BottomLeft\";\r\n    options.helper.getDisplayPropertyName = (path, propertyName) => {\r\n        const dfr = new window.DevExpress.Analytics.Internal.DxDeferred();\r\n        getDisplayName(id, path, propertyName, dotnetHelper).then(displayName => {\r\n            dfr.resolve(displayName);\r\n        });\r\n        return dfr.promise();\r\n    };\r\n    options.value.subscribe((newValue) => {\r\n        const acceptBtn = document.querySelector('.filter-editor-accept-btn');\r\n        acceptBtn === null || acceptBtn === void 0 ? void 0 : acceptBtn.classList.add('dxbl-disabled');\r\n        acceptBtn === null || acceptBtn === void 0 ? void 0 : acceptBtn.setAttribute('disabled', '');\r\n        dotnetHelper.invokeMethodAsync('ValueChanging', newValue).catch(() => { });\r\n    });\r\n    const debouncedValueChanged = debounce((newValue) => {\r\n        dotnetHelper.invokeMethodAsync('ValueChanged', newValue).catch(() => { });\r\n    }, 300);\r\n    options.value.subscribe(debouncedValueChanged);\r\n    return options;\r\n}\r\nfunction initLocalization(filterOptions, initFilterEditor) {\r\n    var localizationCallbacks = [];\r\n    if (filterOptions.customizeLocalization) {\r\n        const eventHandler = getFunctionFromString(filterOptions.customizeLocalization);\r\n        if (typeof eventHandler === \"function\") {\r\n            raiseCustomizeLocalization(filterOptions, eventHandler, localizationCallbacks);\r\n        }\r\n        else {\r\n            console.error(\"Client-side event \" + filterOptions.customizeLocalization + \" was skipped: function \" + filterOptions.customizeLocalization + \" not found.\");\r\n        }\r\n    }\r\n    return window.DevExpress.Analytics.Internal.resolveFromPromises(localizationCallbacks, initFilterEditor);\r\n}\r\nfunction raiseCustomizeLocalization(filterOptions, eventHandler, localizationCallbacks) {\r\n    const args = {\r\n        LoadMessages: (messages) => {\r\n            if (!messages)\r\n                return;\r\n            if (typeof messages.then === 'function') {\r\n                localizationCallbacks.push(messages);\r\n            }\r\n            else {\r\n                window.DevExpress.Analytics.Localization.loadMessages(messages);\r\n            }\r\n        },\r\n        WidgetLocalization: window.DevExpress.localization\r\n    };\r\n    eventHandler(filterOptions, args);\r\n}\r\nfunction createFilterEditor(id, filterOptions, dotnetHelper) {\r\n    const options = getOptions(id, filterOptions, dotnetHelper);\r\n    store[id] = {\r\n        currentType: filterOptions.typeFullName,\r\n        options: options\r\n    };\r\n    const fieldListProvider = getFieldListProvider(id, dotnetHelper);\r\n    const displayNameProvider = getDisplayNameProvider(id, dotnetHelper);\r\n    let model = {\r\n        options: window.ko.observable(options),\r\n        fieldListProvider,\r\n        displayNameProvider,\r\n        getPopupContainer: () => getPopupContainerSelector()\r\n    };\r\n    if (!options.disabled()) {\r\n        const fieldListProviderPromise = fieldListProvider.getItems({ fullPath: \"\", path: \"\" });\r\n        if (fieldListProviderPromise.always) {\r\n            fieldListProviderPromise.always(() => {\r\n                initialize(id, filterOptions.cssClass, model);\r\n            });\r\n        }\r\n    }\r\n    else {\r\n        initialize(id, filterOptions.cssClass, model);\r\n    }\r\n}\r\nfunction initialize(id, cssClass, model) {\r\n    const wrapper = document.getElementById(id);\r\n    wrapper.className = cssClass;\r\n    const editor = getFilterEditorElement(id);\r\n    editor === null || editor === void 0 ? void 0 : editor.classList.add(\"dx-designer\", \"dx-designer-viewport\");\r\n    const filterEditorPlain = document.createElement(\"div\");\r\n    filterEditorPlain.setAttribute(\"data-bind\", dataBindValue);\r\n    filterEditorPlain.classList.add(\"dx-filtereditor-plain\");\r\n    editor === null || editor === void 0 ? void 0 : editor.appendChild(filterEditorPlain);\r\n    window.ko.applyBindings(model, editor);\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\r\n    Init: (filterOptions, id, dotnetHelper) => {\r\n        window.DevExpress.Analytics.Internal.useKoIntegration();\r\n        window.DevExpress.Analytics.Utils.addToBindingsCache(dataBindValue, ($context, $element) => {\r\n            return {\r\n                'component': function () {\r\n                    return {\r\n                        'name': 'dx-filtereditor-plain',\r\n                        'params': {\r\n                            'options': $context.$data.options,\r\n                            'fieldListProvider': $context.$data.fieldListProvider,\r\n                            'displayNameProvider': $context.$data.displayNameProvider\r\n                        }\r\n                    };\r\n                }\r\n            };\r\n        });\r\n        initLocalization(filterOptions, () => createFilterEditor(id, filterOptions, dotnetHelper));\r\n    },\r\n    SetParameters: (filterOptions, id) => {\r\n        if (!store[id])\r\n            return;\r\n        const { currentType, options } = store[id];\r\n        const { typeFullName, cssClass, filter, disabled } = filterOptions;\r\n        if (currentType !== typeFullName) {\r\n            store[id].currentType = typeFullName;\r\n        }\r\n        if (options.value() !== filter) {\r\n            options.value(filter);\r\n        }\r\n        if (options.disabled() !== disabled) {\r\n            options.disabled(disabled);\r\n        }\r\n        const wrapper = document.getElementById(id);\r\n        if (wrapper && wrapper.className !== cssClass) {\r\n            wrapper.className = cssClass;\r\n        }\r\n    },\r\n    SetInvalidState: (errorMessage, id) => {\r\n        const wrapper = document.getElementById(id);\r\n        wrapper === null || wrapper === void 0 ? void 0 : wrapper.classList.toggle(\"invalid-value\", !!errorMessage);\r\n        wrapper === null || wrapper === void 0 ? void 0 : wrapper.setAttribute(\"data-invalid-message\", errorMessage || \"\");\r\n    },\r\n    Dispose: (id) => {\r\n        const element = getFilterEditorElement(id);\r\n        if (element) {\r\n            window.ko.cleanNode(element);\r\n            delete store[id];\r\n        }\r\n    }\r\n});\r\n\n\n//# sourceURL=webpack:///./Scripts/filterBuilder.ts?");

/***/ }),

/***/ "./Scripts/imageComponent.ts":
/*!***********************************!*\
  !*** ./Scripts/imageComponent.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ imageComponent)\n/* harmony export */ });\nclass imageComponent {\r\n    initClick(uploadElementId, element) {\r\n        let parentElement = element === null || element === void 0 ? void 0 : element.closest(\".dxbl-menu-item, .dxbl-context-menu-template\");\r\n        parentElement === null || parentElement === void 0 ? void 0 : parentElement.addEventListener(\"click\", () => {\r\n            window.xaf.uploadComponent.open(uploadElementId);\r\n        });\r\n    }\r\n    initOverlayElement(instance, overlayElement, uploadElementId) {\r\n        overlayElement === null || overlayElement === void 0 ? void 0 : overlayElement.addEventListener(\"click\", async () => {\r\n            let isImageLoaded = overlayElement.getAttribute(\"data-image-loaded\") === 'true';\r\n            if (!isImageLoaded) {\r\n                window.xaf.uploadComponent.open(uploadElementId);\r\n            }\r\n            else {\r\n                let clientRect = overlayElement.getBoundingClientRect();\r\n                var x = clientRect.left + clientRect.width / 2;\r\n                var y = clientRect.top + clientRect.height / 2;\r\n                instance.invokeMethodAsync('OverlayClick', x, y);\r\n            }\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/imageComponent.ts?");

/***/ }),

/***/ "./Scripts/loadingIndicator.ts":
/*!*************************************!*\
  !*** ./Scripts/loadingIndicator.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ loadingIndicator)\n/* harmony export */ });\nclass loadingIndicator {\r\n    constructor() {\r\n        this.delayTimeout = 200;\r\n        this.containerEl = () => document.getElementById(\"xaf-loading\");\r\n        this.indicatorEl = () => document.querySelector(\"#xaf-loading .xaf-loading-content\");\r\n    }\r\n    isShowing() {\r\n        const container = this.containerEl();\r\n        return (container === null || container === void 0 ? void 0 : container.className) === \"xaf-loading show\";\r\n    }\r\n    show() {\r\n        this.startTime = undefined;\r\n        const container = this.containerEl();\r\n        if (container) {\r\n            container.className = \"xaf-loading show\";\r\n        }\r\n        this.timer = setTimeout(() => {\r\n            const indicator = this.indicatorEl();\r\n            if (indicator instanceof HTMLElement) {\r\n                indicator.style.visibility = \"visible\";\r\n                indicator.style.backgroundColor = getComputedStyle(document.body).backgroundColor;\r\n                this.startTime = Date.now();\r\n            }\r\n        }, this.delayTimeout);\r\n    }\r\n    hide() {\r\n        clearTimeout(this.timer);\r\n        const spendTime = this.startTime !== undefined ? Date.now() - this.startTime : undefined;\r\n        if (spendTime !== undefined && spendTime > this.delayTimeout) {\r\n            this.hideCore();\r\n        }\r\n        else {\r\n            setTimeout(() => {\r\n                this.hideCore();\r\n            }, this.delayTimeout);\r\n        }\r\n    }\r\n    hideCore() {\r\n        const container = this.containerEl();\r\n        const indicator = this.indicatorEl();\r\n        if (container) {\r\n            container.className = \"xaf-loading\";\r\n        }\r\n        if (indicator instanceof HTMLElement) {\r\n            indicator.style.visibility = \"hidden\";\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/loadingIndicator.ts?");

/***/ }),

/***/ "./Scripts/loadingPanelObserver.ts":
/*!*****************************************!*\
  !*** ./Scripts/loadingPanelObserver.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ loadingPanelObserver)\n/* harmony export */ });\nclass loadingPanelObserver {\r\n    constructor() {\r\n        this.toolbarObservers = [];\r\n    }\r\n    getAppElement() { return document.querySelector(\"app\"); }\r\n    createToolbarObserver(element) {\r\n        let observer = new MutationObserver((mutationList, observer) => {\r\n            let element = mutationList.find(m => m.type == \"attributes\");\r\n            if (element) {\r\n                let target = element.target;\r\n                if (!target.classList.contains('dxbl-loading')) {\r\n                    let index = this.toolbarObservers.indexOf(observer);\r\n                    if (index !== -1) {\r\n                        this.toolbarObservers.splice(index, 1);\r\n                    }\r\n                    observer.disconnect();\r\n                    if (this.toolbarObservers.length == 0) {\r\n                        this.hideLoadingPanel();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        this.toolbarObservers.push(observer);\r\n        observer.observe(element, { attributes: true });\r\n    }\r\n    hideLoadingPanel() {\r\n        const applicationLoadingPanel = document.getElementById('applicationLoadingPanel');\r\n        if (applicationLoadingPanel) {\r\n            applicationLoadingPanel.remove();\r\n        }\r\n        let appElement = this.getAppElement();\r\n        appElement.style.visibility = '';\r\n        appElement.style.opacity = '';\r\n    }\r\n    isAppLoaded(observer = undefined) {\r\n        let appElement = this.getAppElement();\r\n        if (appElement && appElement.innerText && appElement.innerText.trim()) {\r\n            appElement.classList.remove(\"d-none\");\r\n            if (observer) {\r\n                observer.disconnect();\r\n            }\r\n            this.createLoadingToolbarObservers();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    createLoadingToolbarObservers() {\r\n        const appElement = this.getAppElement();\r\n        const loadingToolbars = document.querySelectorAll(\".dxbl-loading\");\r\n        if (loadingToolbars.length > 0) {\r\n            appElement.style.visibility = 'hidden';\r\n            appElement.style.opacity = '0';\r\n            loadingToolbars.forEach(e => this.createToolbarObserver(e));\r\n        }\r\n        else {\r\n            this.hideLoadingPanel();\r\n        }\r\n    }\r\n    runObserver() {\r\n        if (!this.isAppLoaded()) {\r\n            new MutationObserver((mutationsList, observer) => {\r\n                this.isAppLoaded(observer);\r\n            }).observe(document.body, { childList: true, subtree: true });\r\n        }\r\n    }\r\n    reloadToolbarObservers() {\r\n        this.toolbarObservers.forEach(observer => observer.disconnect());\r\n        this.toolbarObservers = [];\r\n        this.createLoadingToolbarObservers();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/loadingPanelObserver.ts?");

/***/ }),

/***/ "./Scripts/outsideClickComponent.ts":
/*!******************************************!*\
  !*** ./Scripts/outsideClickComponent.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accountComponent: () => (/* binding */ accountComponent),\n/* harmony export */   settingsComponent: () => (/* binding */ settingsComponent)\n/* harmony export */ });\n/* harmony import */ var _closeOutsideClickController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./closeOutsideClickController */ \"./Scripts/closeOutsideClickController.ts\");\n\r\nclass outsideClickComponent {\r\n    constructor(buttonSelector, modalBackDropSelector) {\r\n        this.mainElementId = \"\";\r\n        this.closeOutsideClickController = new _closeOutsideClickController__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n        this.buttonSelector = buttonSelector;\r\n        this.modalBackDropSelector = modalBackDropSelector;\r\n        this.onKeyUp = (ev) => {\r\n            const keyEvent = ev;\r\n            if ((keyEvent === null || keyEvent === void 0 ? void 0 : keyEvent.key.toUpperCase()) === 'ESCAPE' && this.closeOutsideClickController.isVisible(this.mainElementId))\r\n                this.hide();\r\n        };\r\n    }\r\n    init(mainElementId) {\r\n        var _a;\r\n        this.mainElementId = mainElementId;\r\n        this.mainElement = document.getElementById(this.mainElementId);\r\n        const themeButton = (_a = this.mainElement) === null || _a === void 0 ? void 0 : _a.querySelector(this.buttonSelector);\r\n        const modalBackdrop = document.querySelector(this.modalBackDropSelector);\r\n        themeButton === null || themeButton === void 0 ? void 0 : themeButton.addEventListener(\"click\", (ev) => this.toogle());\r\n        document.body.addEventListener(\"keyup\", this.onKeyUp);\r\n        modalBackdrop === null || modalBackdrop === void 0 ? void 0 : modalBackdrop.addEventListener(\"click\", (ev) => this.hide());\r\n    }\r\n    toogle() {\r\n        this.closeOutsideClickController.toggle(this.mainElementId, this.modalBackDropSelector);\r\n    }\r\n    hide() {\r\n        this.closeOutsideClickController.hide(this.mainElementId);\r\n    }\r\n}\r\nclass settingsComponent extends outsideClickComponent {\r\n    constructor() {\r\n        super(\".theme-button\", \".theme-settings-modal-backdrop\");\r\n    }\r\n}\r\nclass accountComponent extends outsideClickComponent {\r\n    constructor() {\r\n        super(\".account-button\", \".account-modal-backdrop\");\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/outsideClickComponent.ts?");

/***/ }),

/***/ "./Scripts/progressbar.ts":
/*!********************************!*\
  !*** ./Scripts/progressbar.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ progressBar)\n/* harmony export */ });\nclass progressBar {\r\n    setProgress(progressBarElement, percent) {\r\n        progressBarElement.setAttribute(\"style\", \"width: \" + percent + \"%;\");\r\n        progressBarElement.setAttribute(\"aria-valuenow\", percent.toString());\r\n    }\r\n    hide(progressBarElement) {\r\n        setTimeout(() => {\r\n            progressBarElement.parentElement.classList.add(\"d-none\");\r\n            this.setProgress(progressBarElement, 0);\r\n        }, 400);\r\n    }\r\n    update(progressBarElement, value, maxvalue) {\r\n        var percent = Math.floor((100 * value) / maxvalue);\r\n        if (progressBarElement.parentElement.classList.contains(\"d-none\")) {\r\n            progressBarElement.parentElement.classList.remove(\"d-none\");\r\n        }\r\n        this.setProgress(progressBarElement, percent);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/progressbar.ts?");

/***/ }),

/***/ "./Scripts/report.ts":
/*!***************************!*\
  !*** ./Scripts/report.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ report)\n/* harmony export */ });\nclass report {\r\n    constructor() {\r\n        this.IsNewReport = false;\r\n        this.ParametersTypesKeysCache = new Set();\r\n    }\r\n    reportViewerCreated(id) {\r\n        window.xaf.resizeObserverUtils.subscribeToResizeObservers(\"#\" + id);\r\n    }\r\n    reportViewerDestroyed(id) {\r\n        window.xaf.resizeObserverUtils.unsubscribeFromResizeObservers(\"#\" + id);\r\n        window.xaf.reportDesignerInstance = undefined;\r\n        window.xaf.reportDesignerActions = undefined;\r\n    }\r\n    nativeReportViewerCreated(id) {\r\n        this.reportViewerCreated(id); // dxbl-form-layout-item:has(.dxbrv-wrapper) .dxbl-fl-ctrl:has(.dxbrv-wrapper)\r\n    }\r\n    nativeReportViewerDestroyed(id) {\r\n        this.reportViewerDestroyed(id);\r\n    }\r\n    onBeforeRenderReportDesigner(s, e) {\r\n        if (this.IsNewReport) {\r\n            var subscription = s.GetDesignerModel().navigateByReports.currentTab.subscribe((newValue) => {\r\n                s.RunWizard(\"DesignInReportWizard\");\r\n                subscription.dispose();\r\n                newValue.url(\"\");\r\n            });\r\n        }\r\n        s.GetDesignerModel().undoEngine.subscribe((undoEngine) => {\r\n            undoEngine.isDirty.subscribe((isDirtyValue) => {\r\n                var onReportDesignerModified = async () => await this.DxReportDesignerContainerReference.invokeMethodAsync(\"InvokeReportModified\", isDirtyValue);\r\n                onReportDesignerModified();\r\n            });\r\n        });\r\n        window.xaf.reportDesignerInstance = s;\r\n    }\r\n    setIsNewReport(isNewReport) {\r\n        this.IsNewReport = isNewReport;\r\n    }\r\n    setParametersTypes(parametersTypes) {\r\n        this.ParametersTypes = parametersTypes;\r\n    }\r\n    setHiddenReportDesignerActions(hiddenActions) {\r\n        this.HiddenReportDesignerActions = hiddenActions;\r\n    }\r\n    setDxReportDesignerContainerReference(DxReportDesignerContainerReference) {\r\n        this.DxReportDesignerContainerReference = DxReportDesignerContainerReference;\r\n    }\r\n    onCustomizeMenuActionsReportDesigner(s, e) {\r\n        if (this.ParametersTypes) {\r\n            this.initParametersTypes(s);\r\n            this.ParametersTypes = null;\r\n        }\r\n        var saveAction = e.GetById(s.dx.Reporting.Designer.Actions.ActionId.Save);\r\n        if (saveAction) {\r\n            saveAction.container = \"toolbar\";\r\n            e.Actions.splice(e.Actions.indexOf(saveAction), 1);\r\n            e.Actions[0].hasSeparator = true;\r\n            e.Actions.splice(0, 0, saveAction);\r\n            var nativeAction = saveAction.clickAction;\r\n            var onReportDesignerReportSaved = async () => await this.DxReportDesignerContainerReference.invokeMethodAsync(\"InvokeReportSaved\");\r\n            saveAction.clickAction = async function () {\r\n                var currentTab = s.GetDesignerModel().navigateByReports.currentTab();\r\n                if (!currentTab.context().url()) {\r\n                    var layout = s.GetDesignerModel().model().serialize();\r\n                    s.dx.Reporting.Designer.ReportStorageWeb.setNewData(layout, '').done((jsonResult) => {\r\n                        currentTab.context().url(jsonResult);\r\n                        currentTab.undoEngine.clearHistory();\r\n                        onReportDesignerReportSaved();\r\n                        s.dx.Analytics.Internal.ShowMessage(s.dx.Analytics.Utils.getLocalization(\"The report has been successfully saved.\", \"ASPxReportsStringId.ReportDesigner_SaveReport_Message_OK\"), s.dx.Analytics.Internal.NotifyType.success);\r\n                    }).fail(function (error) { });\r\n                }\r\n                else {\r\n                    nativeAction();\r\n                    currentTab.undoEngine.clearHistory();\r\n                    onReportDesignerReportSaved();\r\n                }\r\n            };\r\n        }\r\n        for (let index = 0; index < this.HiddenReportDesignerActions.length; ++index) {\r\n            var actions = e.Actions.filter((x) => { return x.id === this.HiddenReportDesignerActions[index]; });\r\n            if (actions.length > 0) {\r\n                e.Actions.splice(e.Actions.indexOf(actions[0]), 1);\r\n            }\r\n        }\r\n        window.xaf.reportDesignerActions = e;\r\n    }\r\n    onBeforeRenderReportViewer(s, e) {\r\n        e.reportPreview.zoom = 1;\r\n        window.addEventListener(\"beforeunload\", () => {\r\n            s.Close();\r\n        }, false);\r\n    }\r\n    initParametersTypes(s) {\r\n        for (var type in this.ParametersTypes) {\r\n            if (!this.ParametersTypesKeysCache.has(type)) {\r\n                s.AddParameterType({ value: type, displayValue: this.ParametersTypes[type], defaultValue: '', typeImage: '' }, null);\r\n                this.ParametersTypesKeysCache.add(type);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/report.ts?");

/***/ }),

/***/ "./Scripts/resizeObserverUtils.ts":
/*!****************************************!*\
  !*** ./Scripts/resizeObserverUtils.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ resizeObserverUtils)\n/* harmony export */ });\nclass resizeObserverUtils {\r\n    constructor() {\r\n        this.subscribers = new Map();\r\n    }\r\n    subscribeToResizeObservers(containerSelector) {\r\n        var containerElements = document.querySelectorAll(containerSelector);\r\n        if (containerElements.length > 1) {\r\n            return;\r\n        }\r\n        if (containerElements.length == 0) {\r\n            window.xaf.resizeObserverUtils.unsubscribeFromResizeObservers(containerSelector);\r\n            return;\r\n        }\r\n        const closestMainContent = containerElements[0].closest(\".dxbl-modal-body, .main.xaf-flex-auto > .main-content\");\r\n        if (closestMainContent && !this.subscribers.has(containerSelector)) {\r\n            try {\r\n                const resizeObserver = new ResizeObserver(entries => {\r\n                    entries.forEach(entry => {\r\n                        window.xaf.resizeObserverUtils.updateContainerViewPortHeight(entry.target, containerSelector);\r\n                    });\r\n                });\r\n                this.subscribers.set(containerSelector, resizeObserver);\r\n                resizeObserver.observe(closestMainContent);\r\n            }\r\n            catch (e) { }\r\n            finally {\r\n                window.xaf.resizeObserverUtils.updateContainerViewPortHeight(closestMainContent, containerSelector);\r\n            }\r\n        }\r\n    }\r\n    updateContainerViewPortHeight(viewPortElement, containerSelector) {\r\n        var containerElements = document.querySelectorAll(containerSelector);\r\n        if (containerElements.length > 1) {\r\n            return;\r\n        }\r\n        if (containerElements.length == 0) {\r\n            window.xaf.resizeObserverUtils.unsubscribeFromResizeObservers(containerSelector);\r\n            return;\r\n        }\r\n        var containerElement = containerElements[0];\r\n        if (containerElement) {\r\n            containerElement.style.height = window.xaf.resizeObserverUtils.getContainerViewPortHeight(viewPortElement, containerElement);\r\n        }\r\n    }\r\n    getContainerViewPortHeight(viewPortElement, containerElement) {\r\n        const props = [\"margin-top\", \"margin-bottom\", \"padding-top\", \"padding-bottom\", \"border-top-width\", \"border-bottom-width\"];\r\n        var offset = 0.0;\r\n        var computedStyles = getComputedStyle(viewPortElement);\r\n        props.forEach((prop) => {\r\n            offset += parseFloat(computedStyles[prop]);\r\n        });\r\n        for (var container = containerElement; container && container !== viewPortElement; container = container.parentElement) {\r\n            computedStyles = getComputedStyle(container);\r\n            props.forEach(prop => {\r\n                offset += parseFloat(computedStyles[prop]);\r\n            });\r\n        }\r\n        return `${viewPortElement.clientHeight - Math.round(offset)}px`;\r\n    }\r\n    unsubscribeFromResizeObservers(containerSelector) {\r\n        const resizeObserver = this.subscribers.get(containerSelector);\r\n        if (resizeObserver) {\r\n            this.subscribers.delete(containerSelector);\r\n            resizeObserver.disconnect();\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/resizeObserverUtils.ts?");

/***/ }),

/***/ "./Scripts/splitter.ts":
/*!*****************************!*\
  !*** ./Scripts/splitter.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dragSplitter: () => (/* binding */ dragSplitter),\n/* harmony export */   registerDotnetReference: () => (/* binding */ registerDotnetReference),\n/* harmony export */   releaseSplitter: () => (/* binding */ releaseSplitter),\n/* harmony export */   resetStyleRelativePosition: () => (/* binding */ resetStyleRelativePosition),\n/* harmony export */   resetStyleSplitterPosition: () => (/* binding */ resetStyleSplitterPosition),\n/* harmony export */   unregisterDotnetReference: () => (/* binding */ unregisterDotnetReference)\n/* harmony export */ });\nlet isDragging = false;\r\nlet splitterElement = null;\r\nlet dragDelta = 0;\r\nlet isDragHorizontal = true;\r\nlet isRelativePositioning = false;\r\nlet splitterViewPaneId = null;\r\nlet firstPaneElement = null;\r\nlet dotnetReferenceMap = new Map();\r\nfunction registerDotnetReference(paneId, dotnetReference) {\r\n    dotnetReferenceMap.set(paneId, dotnetReference);\r\n    const splitterElement = document.querySelector(`[pane-id='${paneId}'] > .xaf-masterdetail-splitter`);\r\n    // It is safe to add this event listener multiple times (duplicate subscriptions are not added again).\r\n    // If the splitter element is not preserved after a MasterDetailLayoutRenderer update or is otherwise\r\n    // re-created between the calls to the current method, this will result in a bug where clicking the\r\n    // splitter element does nothing. There is no evidence of this occurring so far, but if it does, the\r\n    // easiest solution will probably be to turn that element into a web component, like\r\n    // xaf-navigation-click-helper, which can subscribe to events on its own without explicit calls from us.\r\n    splitterElement.addEventListener(\"pointerdown\", dragSplitter);\r\n}\r\nfunction unregisterDotnetReference(paneId) {\r\n    dotnetReferenceMap.delete(paneId);\r\n}\r\nfunction getFirstPaneElement(paneId) {\r\n    return document.querySelector(`[pane-id='${paneId}'] > .xaf-masterdetail-first-pane`);\r\n}\r\nfunction getSecondPaneElement(paneId) {\r\n    return document.querySelector(`[pane-id='${paneId}'] > .xaf-masterdetail-view:not(.xaf-masterdetail-first-pane)`);\r\n}\r\nfunction getSplitterElement(paneId) {\r\n    return document.querySelector(`[pane-id='${paneId}'] > .xaf-masterdetail-splitter`);\r\n}\r\nfunction dragSplitter(e) {\r\n    if (isDragging) {\r\n        // this *can* happen sometimes when the browser for some reason ignores the pointerup event - it's safe to just ignore this error\r\n        return;\r\n    }\r\n    e.preventDefault();\r\n    e.stopImmediatePropagation();\r\n    isDragging = true;\r\n    splitterElement = e.currentTarget;\r\n    splitterElement.setPointerCapture(e.pointerId);\r\n    splitterViewPaneId = e.currentTarget.parentElement.getAttribute(\"pane-id\");\r\n    firstPaneElement = getFirstPaneElement(splitterViewPaneId);\r\n    isRelativePositioning = firstPaneElement.classList.contains(\"xaf-relative-positioning\");\r\n    const computedStyle = getComputedStyle(firstPaneElement);\r\n    isDragHorizontal = firstPaneElement.parentElement.classList.contains(\"direction-horizontal\");\r\n    const initialSize = Number.parseInt(isDragHorizontal ? computedStyle.width : computedStyle.height);\r\n    const secondPaneElement = getSecondPaneElement(splitterViewPaneId);\r\n    firstPaneElement.style.flexGrow = \"0\";\r\n    firstPaneElement.style.flexShrink = \"1\";\r\n    // To make the splitter follow the cursor exactly when resizing, the second pane must be \"flex: 1 1 0\". Ensure that this is true.\r\n    // (the actual style may be different when using ISplitLayoutSizeService to set relative view sizes)\r\n    secondPaneElement.style.flexGrow = \"1\";\r\n    secondPaneElement.style.flexShrink = \"1\";\r\n    if (isDragHorizontal) {\r\n        secondPaneElement.style.flexBasis = \"0\";\r\n    }\r\n    else {\r\n        secondPaneElement.style.flexBasis = \"0%\";\r\n    }\r\n    const splitterRequestAnimationFrame = function () {\r\n        if (!isDragging) {\r\n            return;\r\n        }\r\n        if (isRelativePositioning) {\r\n            firstPaneElement.style.flexBasis = getPercent(initialSize + dragDelta) + \"%\";\r\n        }\r\n        else {\r\n            firstPaneElement.style.flexBasis = initialSize + dragDelta + \"px\";\r\n        }\r\n        requestAnimationFrame(splitterRequestAnimationFrame);\r\n    };\r\n    document.addEventListener(\"pointermove\", isDragHorizontal ? moveSplitterX : moveSplitterY);\r\n    document.addEventListener(\"pointerup\", releaseSplitter, { once: true });\r\n    requestAnimationFrame(splitterRequestAnimationFrame);\r\n}\r\nfunction getPercent(currentPosition) {\r\n    const length = firstPaneElement.parentElement.getBoundingClientRect()[isDragHorizontal ? \"width\" : \"height\"];\r\n    return currentPosition / length * 100;\r\n}\r\nfunction moveSplitterX(e) {\r\n    // See https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX. This can potentially be noticed\r\n    // when trying to move a splitter on a mobile browser in the Desktop mode - the splitter will be lagging behind your finger.\r\n    dragDelta += e.movementX;\r\n}\r\n;\r\nfunction moveSplitterY(e) {\r\n    dragDelta += e.movementY;\r\n}\r\n;\r\nfunction releaseSplitter(e) {\r\n    if (!isDragging) {\r\n        return;\r\n    }\r\n    isDragging = false;\r\n    document.removeEventListener(\"pointermove\", isDragHorizontal ? moveSplitterX : moveSplitterY);\r\n    const newSplitterPosition = firstPaneElement.getBoundingClientRect()[isDragHorizontal ? \"width\" : \"height\"];\r\n    if (isRelativePositioning && isDragHorizontal) {\r\n        sendNewSplitterPosition(dotnetReferenceMap.get(Number.parseInt(splitterViewPaneId)), getPercent(newSplitterPosition));\r\n    }\r\n    else {\r\n        sendNewSplitterPosition(dotnetReferenceMap.get(Number.parseInt(splitterViewPaneId)), newSplitterPosition);\r\n    }\r\n    splitterElement.releasePointerCapture(e.pointerId);\r\n    splitterElement = null;\r\n    dragDelta = 0;\r\n    splitterViewPaneId = null;\r\n    // set this value to the actual new splitter position (otherwise visible splitter position would change\r\n    // after a browser window resize, and then change back unexpectedly after a page refresh)\r\n    if (isRelativePositioning && isDragHorizontal) {\r\n        firstPaneElement.style.flexBasis = getPercent(newSplitterPosition) + \"%\";\r\n    }\r\n    else {\r\n        firstPaneElement.style.flexBasis = newSplitterPosition + \"px\";\r\n    }\r\n    firstPaneElement = null;\r\n}\r\nfunction sendNewSplitterPosition(dotnetReference, splitterPosition) {\r\n    if (dotnetReference) {\r\n        dotnetReference.invokeMethodAsync(\"UpdateSplitterPosition\", splitterPosition); // no need to await this call\r\n    }\r\n}\r\nfunction resetStyleRelativePosition(paneId, relativePosition) {\r\n    var _a;\r\n    const firstPaneElement = getFirstPaneElement(paneId);\r\n    if (firstPaneElement) {\r\n        firstPaneElement.style.cssText = \"\";\r\n    }\r\n    const secondPaneElement = getSecondPaneElement(paneId);\r\n    if (secondPaneElement) {\r\n        secondPaneElement.style.cssText = \"\";\r\n    }\r\n    const splitterElement = getSplitterElement(paneId);\r\n    if (relativePosition > 0 && isRelativePositioning) {\r\n        const computedElement = getComputedStyle(splitterElement);\r\n        const splitterWidth = splitterElement.offsetWidth + Number(computedElement.marginLeft.replace(\"px\", \"\")) + Number(computedElement.marginRight.replace(\"px\", \"\"));\r\n        const splitterPercent = splitterWidth / Number((_a = splitterElement.parentElement) === null || _a === void 0 ? void 0 : _a.offsetWidth) * 100;\r\n        secondPaneElement.style.flexBasis = 100 - relativePosition - splitterPercent + \"%\";\r\n    }\r\n}\r\n;\r\nfunction resetStyleSplitterPosition(paneId, splitterPosition) {\r\n    const firstPaneElement = getFirstPaneElement(paneId);\r\n    if (firstPaneElement) {\r\n        firstPaneElement.style.cssText = \"\";\r\n        firstPaneElement.style.flexBasis = splitterPosition + \"px\";\r\n    }\r\n    const secondPaneElement = getSecondPaneElement(paneId);\r\n    if (secondPaneElement) {\r\n        secondPaneElement.style.cssText = \"\";\r\n    }\r\n}\r\n;\r\n\n\n//# sourceURL=webpack:///./Scripts/splitter.ts?");

/***/ }),

/***/ "./Scripts/themeService.ts":
/*!*********************************!*\
  !*** ./Scripts/themeService.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ themeService)\n/* harmony export */ });\nconst DX_THEME_REGEX = /DevExpress.Blazor.Themes/;\r\nconst BOOTSTRAP_CSS_HREF = '_content/DevExpress.Blazor.Themes/bootstrap-external.bs5.min.css';\r\nclass themeService {\r\n    setCookie(cookieName, value) {\r\n        var maxAge = 60 * 60 * 24 * 365 * 3;\r\n        document.cookie = `${cookieName}=${encodeURIComponent(value)};max-age=${maxAge};path=/;samesite=none;secure`;\r\n    }\r\n    ;\r\n    updateDashboardLinks(isDark) {\r\n        const dashboardLinks = document.querySelectorAll(\"link[link-dashboard-scheme]\");\r\n        dashboardLinks.forEach(link => {\r\n            const { href } = link;\r\n            const targetScheme = isDark ? \".dark.\" : \".light.\";\r\n            const replaceableScheme = isDark ? \".light.\" : \".dark.\";\r\n            if (href.includes(replaceableScheme)) {\r\n                link.href = href.replace(replaceableScheme, targetScheme);\r\n            }\r\n        });\r\n    }\r\n    setSizeMode(cookieName, sizeMode) {\r\n        this.setCookie(cookieName, sizeMode);\r\n    }\r\n    ;\r\n    setCurrentCulture(cookieName, cultureName) {\r\n        this.setCookie(cookieName, cultureName);\r\n    }\r\n    ;\r\n    async setTheme(linkId, cookieName, themeName, themeHref, isDark, customLinks) {\r\n        const oldThemeLink = document.getElementById(linkId);\r\n        if (!oldThemeLink) {\r\n            console.error(`Cannot find link element with id: \"${linkId}\"`);\r\n            return;\r\n        }\r\n        const oldCustomLinks = Array.from(document.querySelectorAll(\"link[custom-link]\"));\r\n        function createLink(url, isPrimaryUrl, updateLinkId = true) {\r\n            const link = document.createElement(\"link\");\r\n            link.type = \"text/css\";\r\n            link.rel = \"stylesheet\";\r\n            link.href = url;\r\n            if (!isPrimaryUrl) {\r\n                link.setAttribute('custom-link', '');\r\n            }\r\n            let resolveFunc, rejectFunc;\r\n            const loadPromise = new Promise((resolve, reject) => {\r\n                resolveFunc = resolve;\r\n                rejectFunc = reject;\r\n            });\r\n            link.addEventListener(\"load\", ev => resolveFunc());\r\n            link.addEventListener(\"error\", ev => rejectFunc());\r\n            if (isPrimaryUrl && updateLinkId) {\r\n                oldThemeLink.id = '';\r\n                link.id = linkId;\r\n                oldThemeLink.after(link);\r\n            }\r\n            else {\r\n                document.head.appendChild(link);\r\n            }\r\n            return loadPromise;\r\n        }\r\n        async function updateBootstrapLinkIfNeed(themeUrl) {\r\n            const bootstrapLink = document.querySelector(`link[href=\"${BOOTSTRAP_CSS_HREF}\"]`);\r\n            if (DX_THEME_REGEX.test(themeUrl) && bootstrapLink) {\r\n                bootstrapLink.remove();\r\n            }\r\n            else if (!DX_THEME_REGEX.test(themeUrl) && !bootstrapLink) {\r\n                await createLink(BOOTSTRAP_CSS_HREF, true, false);\r\n            }\r\n        }\r\n        const loadPromises = [\r\n            createLink(themeHref, true),\r\n            updateBootstrapLinkIfNeed(themeHref),\r\n            ...(customLinks !== null && customLinks !== void 0 ? customLinks : []).map(href => createLink(href, false))\r\n        ];\r\n        try {\r\n            await Promise.all(loadPromises);\r\n        }\r\n        catch {\r\n            console.error(`Failed setting the current theme with arguments: ${JSON.stringify(arguments)}`);\r\n            // The server will incorrectly assume that the theme was changed successfully.\r\n            // The following options were considered and rejected:\r\n            //     - throw an error explicitly: this would result in the application crashing;\r\n            //     - return a true|false value to indicate the result: it would be a breaking API change.\r\n            // We don't try to revert to the previous theme here. Such theme rollback would be difficult\r\n            // to implement (consider that multiple calls to this method can run concurrently),\r\n            // and any visual glitches can be fixed by simply refreshing the page.\r\n            return;\r\n        }\r\n        oldCustomLinks.concat(oldThemeLink).forEach(link => link.remove());\r\n        this.updateDashboardLinks(isDark);\r\n        this.setCookie(cookieName, themeName);\r\n    }\r\n    ;\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/themeService.ts?");

/***/ }),

/***/ "./Scripts/uploadComponent.ts":
/*!************************************!*\
  !*** ./Scripts/uploadComponent.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ uploadComponent)\n/* harmony export */ });\nconst store = {};\r\nclass uploadComponent {\r\n    open(id) {\r\n        const clickEvent = new MouseEvent(\"click\", {\r\n            \"view\": window,\r\n            \"bubbles\": false,\r\n            \"cancelable\": true\r\n        });\r\n        const fileInputElement = document.getElementById(id);\r\n        if (fileInputElement) {\r\n            fileInputElement.dispatchEvent(clickEvent);\r\n        }\r\n    }\r\n    canShowFileDialog(inputId) {\r\n        return !store[inputId] && !document.getElementById(inputId).disabled;\r\n    }\r\n    setIsUploading(inputElement, value) {\r\n        store[inputElement.id] = value;\r\n    }\r\n    init(options) {\r\n        const inputElement = options.inputElement;\r\n        store[inputElement.id] = false;\r\n        inputElement.addEventListener('change', function () {\r\n            const file = inputElement.files[0];\r\n            if (!file)\r\n                return;\r\n            const maxFileSize = options.maxFileSize;\r\n            if (maxFileSize && maxFileSize > 0 && file.size > maxFileSize) {\r\n                alert(options.fileSizeLimitMessage);\r\n            }\r\n            else {\r\n                const fileInfo = {\r\n                    name: file.name,\r\n                    size: file.size,\r\n                    type: file.type\r\n                };\r\n                inputElement.readPromise = new Promise((resolve, reject) => {\r\n                    const reader = new FileReader();\r\n                    reader.onload = function () { resolve(reader.result); };\r\n                    reader.onerror = function (err) { reject(err); };\r\n                    reader.readAsArrayBuffer(file);\r\n                });\r\n                options.instance.invokeMethodAsync('Upload', fileInfo);\r\n            }\r\n        });\r\n    }\r\n    clear(inputElement) {\r\n        inputElement.value = \"\";\r\n    }\r\n    readFileData(inputElement, startOffset, count) {\r\n        return inputElement.readPromise.then((arrayBuffer) => {\r\n            return new Uint8Array(arrayBuffer, startOffset, count);\r\n        });\r\n    }\r\n    dispose(inputElement) {\r\n        if (inputElement) {\r\n            delete store[inputElement.id];\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/uploadComponent.ts?");

/***/ }),

/***/ "./Scripts/xafContextMenuClickHelper.ts":
/*!**********************************************!*\
  !*** ./Scripts/xafContextMenuClickHelper.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ XafContextMenuClickHelper)\n/* harmony export */ });\n// helps process clicks on \"xaf-prevent-contextmenu\" elements\r\nclass XafContextMenuClickHelper extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n        this._isInitialized = false;\r\n    }\r\n    connectedCallback() {\r\n        if (!this._isInitialized) {\r\n            this._isInitialized = true;\r\n            // prevents right-click from showing default browser context menu\r\n            this.addEventListener(\"contextmenu\", (ev) => {\r\n                const isPreventContextMenu = ev.composedPath().find(el => { var _a; return (_a = el.classList) === null || _a === void 0 ? void 0 : _a.contains(\"xaf-prevent-contextmenu\"); });\r\n                const isLinkClicked = ev.composedPath().find(el => {\r\n                    var _a;\r\n                    let tagName = (_a = el.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase();\r\n                    return tagName === \"a\" || tagName === \"input\";\r\n                });\r\n                if (isLinkClicked) {\r\n                    ev.stopImmediatePropagation();\r\n                }\r\n                else {\r\n                    if (isPreventContextMenu) {\r\n                        ev.preventDefault();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/xafContextMenuClickHelper.ts?");

/***/ }),

/***/ "./Scripts/xafNavigationClickHelper.ts":
/*!*********************************************!*\
  !*** ./Scripts/xafNavigationClickHelper.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ XafNavigationClickHelper)\n/* harmony export */ });\n// helps process clicks on <a> elements in the navigation component's markup\r\nclass XafNavigationClickHelper extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n        this._isInitialized = false;\r\n    }\r\n    connectedCallback() {\r\n        if (!this._isInitialized) {\r\n            this._isInitialized = true;\r\n            // prevents regular clicks (e.g. left mouse button) on a link\r\n            this.addEventListener(\"click\", (ev) => {\r\n                const isLinkClicked = ev.composedPath().find(el => { var _a; return ((_a = el.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === \"a\"; });\r\n                if (isLinkClicked) {\r\n                    ev.preventDefault();\r\n                }\r\n            });\r\n            // allows ctrl-clicks on a link\r\n            this.addEventListener(\"click\", ev => {\r\n                if (ev.ctrlKey) {\r\n                    ev.stopImmediatePropagation();\r\n                    const isFakeLinkClicked = ev.composedPath().find(element => {\r\n                        var _a;\r\n                        const htmlElement = element;\r\n                        return ((_a = htmlElement.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === \"a\" && htmlElement.getAttribute(\"href\") === \"#\";\r\n                    });\r\n                    if (isFakeLinkClicked) {\r\n                        ev.preventDefault();\r\n                    }\r\n                    else {\r\n                        let auxclickEvent = new MouseEvent(\"auxclick\", ev);\r\n                        this.dispatchEvent(auxclickEvent);\r\n                    }\r\n                }\r\n            }, { capture: true });\r\n            // prevents auxiliary clicks (e.g. middle mouse button) on <a href=\"#\">-like elements\r\n            this.addEventListener(\"auxclick\", ev => {\r\n                const isFakeLinkClicked = ev.composedPath().find(element => {\r\n                    var _a;\r\n                    const htmlElement = element;\r\n                    return ((_a = htmlElement.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === \"a\"\r\n                        && htmlElement.getAttribute(\"href\") === \"#\";\r\n                });\r\n                if (isFakeLinkClicked) {\r\n                    ev.preventDefault();\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./Scripts/xafNavigationClickHelper.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./Scripts/app.ts");
/******/ 	
/******/ })()
;